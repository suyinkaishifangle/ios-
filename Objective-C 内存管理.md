# Objective-C 内存管理

## 内存中的五大区域

iOS的内存的五大区域：栈区、堆区、全局/静态区、常量区、代码区。

![iOS内存五大区域](media/15292150092877/iOS%E5%86%85%E5%AD%98%E4%BA%94%E5%A4%A7%E5%8C%BA%E5%9F%9F.png)

当一个程序启动后，代码区、常量区、全局/静态区大小已固定，因此指向这些区的指针不会产生崩溃性的错误。而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入弹出），所以当使用一个指针指向这两个区里面的内存时，一定要注意内存是否已经被释放。如果只分配内存而不释放内存，会产生内存泄露（leak memory）。

### 栈区（stack）

栈区的地址**从高到低分配**，由**系统自动分配和释放**，**存放方法（函数）的参数值**，**局部变量**的值等。采用「先进后出」的原则。栈特点是有序、速度快、容量小，开发者不需要管理栈区变量的内存，栈区是一块**连续的内存区域**。栈区就是函数（方法）运行时向系统请求的内存。栈中的局部变量，参数由编译器分配和释放，函数运行就分配，函数结束就释放，由系统完成。是系统数据结构，对应进程唯一。系统栈的剩余空间大于所申请的空间，系统为程序提供内存，否则，报错异常，提示栈的溢出。

### 堆区（heap）

堆区的地址**从低到高分配**，由**程序员分配和释放（ARC 自动插入分配和释放代码）**，**存放实例对象**，例如 `alloc` 申请的会放入堆中。如果不释放，则出现**内存泄露**。程序退出时，系统会回收内存。特点：无序、速度慢、容量大。堆区是**不连续的内存区域**，系统用链表储存空闲地址的。链表遍历由低向高。堆大小直接受设备有效虚拟内存影响。

1. 操作系统有一个记录空闲内存地址的链表。
2. 当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。
3. 由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

堆区的内存是应用程序共享的。

### 全局区/静态区（static）

静态变量和全局变量是存储在一起。包括两个部分：未初始化的 、已初始化的。也就是初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放。

> 代码1：未初始化和初始化的变量

```ObjectiveC
int a;          //未初始化的
int b = 10;     //已初始化的
``` 

### 常量区

存放常量的内存区域，程序结束时，由系统释放。

### 代码区

存放二进制代码的区域。

## Objective-C 内存管理的方式

在了解 Objective-C 内存管理方式前，首先需要知道一个问题，那就是「为什么需要管理内存」？。

第一，这里的管理主要分为两种方式，一种是开发者管理（在代码中实现对内存的管理），另一种就是程序自动管理。因为不同的开发语言对内存管理的方式不同，有的语言的内存管理是自动进行的，开发者不必考虑内存管理的问题，而有的语言是需要开发者手动管理内存的，（当然也可以在自动和手动结合的方式管理内存）。

第二，就是问题的本身，为什么需要管理内存？就像人的生老病死，程序中的对象也是有生命周期的，而对象的「生命活动」是需要内存支持的。对象的生命周期包括诞生（通过 alloc 或 new 方法实现）、生存（接收消息并执行操作）、交友（通过复合以及向方法传递参数）和最终死去（被释放）。当一个对象的生命周期结束时，它们的原材料（内存）将被回收以供新的对象使用。如果只分配内存而不释放内存，那么就会发生内存泄漏。

Objective-C 语言以前是需要开发者手动管理内存的，但是在 iOS 5 中引入了 ARC （自动引用计数，Automatic Reference Counting），开发者不再需要手动管理内存，详见下文「自动引用计数」章节。

### 创建对象

Objective-C 创建对象有两种方式：

- 一种是先调用 alloc 方法来申请空间，然后调用 init 等初始化方法。  
- 另一种是调用构造器方法。例如 NSString 类中定义了一个名为 `stringWithString:` 的类方法。

   ```ObjectiveC
    // 调用 alloc/init 方法
    NSString *string = [[NSString alloc] init];
    // 调用构造器方法
    NSString *string = [NSString stringWithString:@"这是一个字符串"];
    ``` 

这两种方法创建的对象在内存管理上存在不同。第一种方法创建对象，需要负责调用 `release` 方法回收内存；如果用第二种方法创建对象，不需要手动释放这种对象占用的内存，系统会自动回收，如果强行回收的话反而可能会导致应用崩溃。一般来说，这种对象所占用的内存会在方法结束时回收，除开在此之前被显式的引用（即调用其 `retain` 方法）。


### 引用计数

Cocoa 采用的是引用计数（reference counting）的技术，也叫做保留计数（retain counting）。每个 Objective-C 对象都有一个属性 `retainCount`，称作引用计数器或保留计数器，它的类型是 NSUInteger。当对象被创建时，它的引用计数器的值默认为 1。当一个新的引用指向该对象时（即某段代码需要访问该对象），将对象的引用计数器的值加 1；当这个对象被减少一次引用时（即这段代码结束对象访问时），将对象的引用计数器的值减 1；依此类推，当对象的引用计数器的值为 0 时，表示这个对象没有被引用（即不再有代码访问该对象），系统这时会自动调用该对象的 `dealloc` 方法销毁对象，释放内存资源。

> ⚠️ **注意**
> 
> 当一个对象因为引用计数器的值归 0 而即将被销毁时，Objective-C 会自动向对象发送一条 `dealloc` 的消息。可以重写 `dealloc` 方法，但是一定不要手动调用 `dealloc` 方法，Objective-C 会在需要销毁对象的时候自动调用它。

#### 引用计数控制规则

- 使用 `alloc`、`new` 方法或通过 `copy` 消息（接收到 copy 消息的对象会创建一个自身的副本）创建一个对象时，对象的引用计数器的值被设置为 1。

- 给对象发送一条 `retain` 消息，那么对象的引用计数器的值就会加 1。

- 给对象发送一条 `release` 消息，那么对象的引用计数器的值就会减 1。

- 给对象发送一条 `retainCount` 消息，那么就可以获取到这个对象的引用计数器的值。

- 当对象的引用计数器的值为 0 时，Objective-C 给对象发送 `dealloc` 消息销毁对象。

> ⚠️ **注意**
> 
> 赋值不会增加引用计数器的值，例如：`NSString *name = @"Sixi";` 并不会增加 name 对象的引用计数器的值。

#### 对象所有权

对象所有权（object ownership）表示一个对象内有指向其他对象的成员变量（即指针）。一般称该对象拥有（或持有）另外的对象。

### 自动释放池

Cocoa 中有一个自动释放池（autorelease pool）的概念。它是一个用来存放对象的集合，并且能够自动释放。

NSObject 类提供了一个叫做 `autorelease` 的方法。该方法预先设定会在未来的某个时刻发送 `release` 消息。它的返回值是接受这条消息的对象。当给一个对象发送 `autorelease` 消息时，实际上是将该对象添加到了自动释放池中。当自动释放池被销毁时，会向该池中的所有对象发送 `release` 消息。

有两种方法可以创建一个自动释放池：

- 使用 @autoreleasepool 关键字。
- 使用 NSAutoreleasePool 对象。

如果是使用 NSAutoreleasePool 对象来创建自动释放池，那么在创建和释放 NSAutoreleasePool 对象之间的代码就是使用自动释放池。

#### @autoreleasepool 块

@autoreleasepool{} 块定义自动释放池的上下文，任何在该上下文（花括号内）中创建的对象都由 ARC 来自动释放，并且在自动释放池结束时销毁这些对象。

如果程序在执行过程中创建了大量的临时对象（比如在循环中创建的临时对象），这些临时对象是在自动释放池被销毁是释放，所以可能会占用大量内存，程序此时可以考虑将 @autoreleasepool{} 块放在循环体内，如下代码：

```Objective-C
for (int = 0; i < 100; i++) {
    @autoreleasepool{
        // 创建临时对象
        // 调用临时对象的方法
        ...
    }
}
```

上述代码在循环体每次执行完成时，都会销毁这些临时对象，从而避免在整个循环结束时才销毁临时对象，这样才能更好的管理内存。

### 自动引用计数

自动引用计数（Automatic Reference Counting），简称 ARC，是 Objective-C 和 Swift 的内存管理机制，使用 ARC，开发者不再需要手动的管理内存。

在 iOS 5 以前，开发者需要手动管理内存，即**手动引用计数**（Manual Reference Counting），简称 MRC，也叫**手动保留释放**，简称 MRR。虽说这种方式提供了面向对象的内存管理接口，但是开发者不得不花大量的时间在内存管理上，并且容易出现内存泄漏或者 release 一个已被释放的对象，导致程序崩溃。iOS 5 及以后，Apple 对 iOS 和 macOS 开发引入了 ARC。使用 ARC，开发者不再需要手动的编写 retain/release/autorelease 语句。 编译器会自动插入对应的代码，再结合 Objective-C 的 runtime，实现自动引用计数。

> ⚠️ **注意**
> 
> 需要明白的是，ARC 预编译的步骤，它只是在代码中自动插入 retain/release/autorelease 语句。内存管理仍然是通过，引用计数实现的，只是引用计数变成了自动的，不需要开发者手动实现。

```ObjectiveC
// ARC 代码
NSObject * obj = [[NSObject alloc] init];   // 引用计数为 1

//MRC 代码
NSObject * obj = [[NSObject alloc] init];   // 引用计数为 1
[obj release];                              // 引用计数为 0
``` 

### 强引用和弱引用

在 iOS 内存管理中，使用 `__strong` 和 `__weak` 关键字来修饰对象的引用。在 ARC 中，`__strong` 表示强引用（strong reference），`__weak` 表示弱引用（weak reference）。简单的说，强引用持有对象，而弱引用不持有对象。

使用 `NSObject *obj = [[NSObject alloc] init]` 这样的语句开辟一块内存并初始化它，并且会将分配好的内存地址赋值给一个变量（即 obj，其实他就是一个指针变量），而在这个过程中，默认是使用 `__strong` 来修饰的，即强引用。这意味着，只要引用存在，对象就不能被销毁。而如果没有强引用只有弱引用，则对象就会被销毁。举个生活的例子：

假设有一头牛，被一根粗绳子牵着绑在树上，牛无法挣脱，而如果是一根细绳子，牛就可以挣脱。这时牛被一根粗绳子牵着，然后再加上一根细绳子，牛还是无法挣脱的。如果把粗绳子去掉，只剩下细绳子，牛就可以挣脱了。

上面的例子中，「粗绳子」相当于「强引用」，「细绳子」相当于「弱引用」，「牛」就相当于「内存空间」，「牛挣脱绳子」就相当于「内存被释放」。这样就好理解了，当一个对象不再有强引用类型的指针指向它的时候，它就会被释放，即便该对象还有弱引用类型的指针指向它。也可以理解为：一旦最后一个指向该对象强引用类型的指针不再指向这个对象（即对象的生命周期结束），这个对象将被释放，如果这个时候还有弱引用指针指向该对象，则会清除掉所有剩余的弱引用指针。

从引用计数的角度看，使用强引用是将对象的引用计数器的值加了 1，而使用弱引用则不改变该对象的引用计数器的值。

```ObjectiveC
NSObject *obj1 = [[NSObject alloc] init];   // 分配对象，分配 retainCount = 1
NSObject *obj2 = obj1;                      // 强引用，retainCount = 2
__weak NSObject *obj3 = obj1;               // 弱引用，retainCount 不变
NSLog(@"%@, %@, %@", obj1, obj2, obj3);
// 输出为：<NSObject: 0x60000001a3b0>, <NSObject: 0x60000001a3b0>, <NSObject: 0x60000001a3b0>
 
obj1 = nil;                               // retainCount = 1
NSLog(@"%@, %@, %@", obj1, obj2, obj3);
// 输出为：(null), <NSObject: 0x60000001a3b0>, <NSObject: 0x60000001a3b0>

obj2 = nil;                               // retainCount = 0，内存被释放
NSLog(@"%@, %@, %@", obj1, obj2, obj3);
// 输出为：(null), (null), (null)
``` 

上述代码中，obj1 和 obj2 没有使用 `__strong` 或者 `__weak`，表示默认使用 `__strong`。obj3 使用 `__weak` 修饰。obj1、obj2 和 obj3 引用的都是同一块内存地址 `0x60000001a3b0`。当强引用 obj1 和 obj2 都为 `nil` 时，对象的引用计数器变为 0，内存被释放，弱引用此时无效。

那么强引用和弱引用在开发中的实际作用是什么？平时一般是强引用，也就是默认不添加，在会造成循环引用问题时才使用弱引用。比如 `delegate` 属性的修饰符都是使用弱引用（属性修饰符中的 `strong` 和 `weak` 表示该属性的引用类型）。




