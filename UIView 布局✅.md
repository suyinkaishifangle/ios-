# UIView 布局✅

## 布局简介

对于移动开发来说，一个应用程序的好坏很大程度上取决于 UI 界面，而布局直接影响 UI 界面。在应用程序中，用户直接能看到的就是界面。而在 iOS 中，布局是针对 UIView 类及其子类来说的。大部分界面外观是由视图类及其子类支撑的，所以对视图的布局尤为重要。

因为应用程序是动态运行的，所以用户界面不会是固定不变的，开发者需要构建动态响应内部或外部变化的用户界面。

**外部变化**

父视图的大小或形状发生变化时会发生外部变化。每次变化时，都必须更新视图层次结构的布局，以便最好地利用可用空间。以下是外部变化的一些常见原因：

- 用户在 iPad 上输入或离开拆分视图。
- iOS 设备旋转。
- 适配不同的 iOS 设备。
- 支持不同大小的类。

这些变化大部分都可能在运行时发生，所以需要应用程序动态响应。 

**内部变化**

当用户界面中的视图或控件的大小发生变化时，会发生内部变化。以下是内部变化的一些常见原因：
 
- 应用程序显示的内容发生变化。
- 应用程序支持国际化（例如不同的文字等长短不同）。
- 应用程序支持动态类型（例如用户手动更改应用中使用的字体大小）。

当应用程序的内容发生变化时，新内容可能需要与旧内容不同的布局。例如，新闻应用程序需要根据各个新闻文章的大小调整其布局。

在 iOS 中，从大的分类上说，布局用户界面可以分为两种方式：**手动布局**和**自动布局**。

- 手动布局
- 自动布局
    - 自动调整（Autoresizing Masks）
    - 使用约束布局

## 手动布局

手动布局即使用视图的 frame 属性进行布局。

使用 frame 属性布局是最常用的方式，通常使用 `initWithFrame:` 方法在创建视图对象的时候对该视图对象的 frame 属性赋值，或者创建完对象之后，单独使用 `frame` 属性赋值。

frame 属性是用于描述视图在父视图坐标系中的大小和位置，所以当父视图变化的时候，子视图也会随着父视图的变化。但是由于 iOS 设备的不同，屏幕大小也在发生着变化，所以视图层次结构最底层的窗口对象的坐标系会变化，那么添加到窗口上的视图如果是使用 frame 属性布局，就有可能造成在不同设备上的布局不同，所以需要开发人员正确计算视图的 frame 值，但是在实际开发中计算每一个视图的 frame 值比较影响开发速度。

在许多方面，手动布局具有一定的灵活性和功能，当发生视图变化时，可以根据需要进行更改。但是应用程序不会自动改变 frame 属性，必须由开发者管理所有更改。因此布置简单的用户界面需要花费大量精力进行设计，调试和维护。创建真正的自适应用户界面会使难度增加一个数量级。

### 优化手动布局

在使用手动布局时，经常需要获取父视图和兄弟视图的 frame、bounds 和 center 属性。而 frame，bounds 和 center 属性的值都是结构体类型，所以需要写较长的语句来获取具体的坐标或宽度高度。并且无法单独为其中的坐标或宽高的某一项赋值。

根据以上原因，可以实现一个针对 UIView 的分类，能够大大减少代码量并且使程序更加简洁。

### 手动布局自定义视图的子视图

视图类中的 `layoutSubviews` 方法用于手动布局，但是手动布局的代码也可以不放在此方法中。在自定义的视图类中，如果将子视图的手动布局代码放在初始化的方法中，那么子视图的布局只会执行一次（即初始化的时候布局），如果之后需要修改父视图的宽高（修改原点坐标无影响，因为子视图根据父视图的坐标系来定位），那么子视图的布局就不会随着父视图大小的变化而变化，因为子视图的布局代码只会执行一次。

而如果将子视图的布局代码放在 `layoutSubviews` 方法中，此方法会在父视图改变时调用，所以如果将子视图的手动布局代码写在此方法中，那么每当父视图变化时，子视图就能够跟随父视图变化，前提是设置正确的手动布局代码。`layoutSubviews` 方法在以下情况下会被自动调用：

- 调用父视图的 `addSubview:` 方法添加视图时。
- 视图的宽高发生变化时（只修改原点坐标不会调用）。
- 滚动一个 UIScrollView 类型的视图时。
- 界面方向发生变化（应用程序横竖屏切换）时。
- 调用视图的 `setNeedsLayout` 或 `layoutIfNeeded` 方法来强制进行布局时。

> ⚠️ **注意**
> 
> 1. 上面讨论的都是是否调用 `layoutSubviews` 方法，而不是调用几次该方法，而且不同的情况调用该方法次数也不同，比如调用了 `addSubview:` 方法后立即修改视图的宽高，也只会调用一次 `layoutSubviews` 方法。不过不需要考虑调用次数的问题，因为只要调用了该方法就能够更新子视图的布局，即使多次调用不会有丝毫影响。
> 2. 实际测试发现只修改视图的原点坐标而不改变视图的宽高时，使用有的值会调用视图的 `layoutSubviews` 方法，但是有的值又不会调用视图的 `layoutSubviews` 方法。不过可以不考虑，因为只修改视图原点坐标不修改其宽高时，对子视图的布局毫无影响。

除了上面列举的情况会自动调用 `layoutSubviews` 方法外，还可以通过手动调用 `setNeedsLayout` 和 `layoutIfNeeded` 方法来让系统调用 `layoutSubviews` 方法。例如某些情况下没有满足自动调用的 `layoutSubviews` 方法的条件，但是又需要调用该方法来让子视图进行布局，就可以手动调用 `setNeedsLayout` 和 `layoutIfNeeded` 方法，这两个方法的具体作用如下：

- **setNeedsLayout** 方法

    使视图的当前布局无效并在下一个更新周期中触发布局更新（即调用 `layoutSubviews` 方法）。

    如果要调整视图的子视图布局，在主线程上调用此方法。此方法记录请求并立即返回。由于此方法不强制立即更新，而是等待下一个更新周期，因此可以在更新任何视图之前使用它来使多个视图的布局无效。此行为允许将所有布局的更新合并到一个更新周期，这通常会提高性能。

- **layoutIfNeeded** 方法

    强制视图立即更新其布局（即立即调用 `layoutSubviews` 方法）。
    
### 手动布局视图控制器根视图的子视图

因为视图控制器的根视图（即视图控制器的 `view` 属性指向的视图）是 UIView 类型的对象，而不是 UIView 的子类，而UIView 的实现是私有的，所以无法重写其 `layoutSubviews` 方法。在这种情况下，当遇到视图控制器的根视图布局改变的时候，就无法修改根视图的子视图的布局。

不过可以通过以下两种方式来解决这个问题：

- **使用自定义视图类作为视图控制器的根视图**

    重写视图控制器的 `loadView` 方法，将根视图设置为自定义的视图对象，这样就能够在自定义的视图类的实现中重写其 `layoutSubviews` 方法。

- **重写视图控制器的 `viewWillLayoutSubviews` 方法**

    此方法的作用和 `layoutSubviews` 方法类似，不过此方法用于布局视图控制器根视图的子视图。每当根视图的布局变化之后，就会自动调用此方法。可以将根视图的子视图的手动布局代码写在此方法中，用来根据根视图变化时，重新布局子视图。

## 自动布局

> 📚 官方文档：**[Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1)**

### 自动调整大小（Autoresizing）

UIView 的 `autoresizesSubviews` 属性和 `autoresizingMask` 属性用于自动调整视图在父视图边界发生变化时如何自动改变子视图的大小。它与约束有定义区别，常在使用 xib 和 storyboard 的开发中用到。

`autoresizesSubviews` 属性用于视图在父视图的边界变化时是否自动调整其大小。`autoresizingMask` 属性用于确定视图在自动调整其大小的情况下如何调整。如果 `autoresizesSubviews` 设置为 `YES`，系统会自动创建一组约束来匹配 `autoresizingMask` 属性指定的调整类型，这组约束能够指定视图的大小和位置。

如果一个视图使用了自动调整大小这种方式来自动布局，并且此时再对这个视图创建其他约束，那么就会导致约束冲突。这种情况下，通过设置视图的 `translatesAutoresizingMaskIntoConstraints` 属性用来确定系统是否要创建约束，使用纯代码编写时该属性默认值为 `YES`，而使用 xib 和 storyboard 时，该属性默认值为 `NO`。当需要自定义约束时，就需要设置这个属性为 `NO`，让系统不自动创建约束，避免发生约束冲突。

不过实际上在开发中，使用纯代码时即使不设置 `translatesAutoresizingMaskIntoConstraints` 属性为 `NO` 也能够创建不冲突的约束。因为 `autoresizingMask` 属性的默认值为 `UIViewAutoresizingNone`，表示不自动调整视图（即不会自动创建约束）。不过为安全考虑，只要需要为视图创建约束，那么最好将 `translatesAutoresizingMaskIntoConstraints` 属性的值设置为 `NO`。

### 使用约束布局

约束通常表示两个视图之间的关系，可以使用一系列**约束（constraint）**来定义用户界面的布局。为视图创建相应的约束，然后自动布局技术会根据这些约束计算每个视图的大小和位置。这会生成动态响应内部和外部更改的布局。例如，可以约束一个按钮，使其与图像视图水平居中，并使按钮的上边缘始终保持在图像底部下方 8pt。 如果图像视图的大小或位置发生变化，则按钮的位置会自动调整以匹配。

#### 约束详解

视图层次结构的布局定义为一系列线性方程式。 每个约束代表一个方程。而开发者需要做的是声明一系列具有唯一结果的方程式，从而确定视图的布局。

![约束定义公式](media/15530840120043/%E7%BA%A6%E6%9D%9F%E5%AE%9A%E4%B9%89%E5%85%AC%E5%BC%8F.png)

上述方程表示「Red 视图的右边界距离 Blue 视图的左边界的距离是 8」，下面是它每一项的含义：

-   **Item 1**：被约束的视图。这里指 Red 视图。
-   **Attribute 1**：约束在第一个项目上的属性。这里指 Red 视图的前部边缘。

    通常，可以约束的属性包括四个边界（视图的顶、底、左和右边界）、高度、宽度、垂直和水平中心以及前部边缘和后部边缘（文本项还具有一个或多个基线属性）。

-   **Relationship**：左右两侧的关系。这里指等于。

    关系可以具有三个值之一：**等于**、**大于或等于**以及**小于或等于**。

-   **Multiplier**：Attribute 2 的值乘以此浮点数。这里乘数是 1.0。
-   **Item 2**：约束依赖的视图，可以为空。这里是 Blue 视图。
-   **Attribute 2**：约束在第一个项目上的属性。如果 Item 2 为空，则必须为 `Not an Attribute`。这里是 Blue 视图的后部边缘。
-   **Constant**：常数，表示约束的值，这里是 8pt。

大多数约束定义了用户界面中两个项之间的关系。约束还可以定义单个项目的两个不同属性之间的关系，例如，在项目的高度和宽度之间设置宽高比。还可以为项目的高度或宽度指定常量值。使用常量值时，**Item 2** 为空，**Attribute 2** 设置为 `Not an Attribute`，乘数设置为 0.0。

#### 自动布局的属性

上面方程中使用的属性，包含在 NSLayoutAttribute 这个枚举中，具体枚举值如下表。这里没有列举完所有的枚举值，因为没有列举的值，在实际开发中基本用不上，如果需要参考📚官方文档 **[NSLayoutAttribute](https://developer.apple.com/documentation/uikit/nslayoutattribute?language=occ)**。

| NSLayoutAttribute 枚举值 | 说明 |
| :-: | :-: |
| NSLayoutAttributeLeft | 对象的矩形的左边界 | 
| NSLayoutAttributeRight | 对象的矩形的右边界 |  
| NSLayoutAttributeTop | 对象的矩形的顶边界 |  
| NSLayoutAttributeBottom | 对象的矩形的底边界 |  
| NSLayoutAttributeLeading | 对象的矩形的前部边缘 |  
| NSLayoutAttributeTrailing | 对象的矩形的后部边缘 |  
| NSLayoutAttributeWidth | 对象的矩形的宽度 |  
| NSLayoutAttributeHeight | 对象的矩形的高度 |  
| NSLayoutAttributeCenterX | 对象的矩形的 X 轴中心 |  
| NSLayoutAttributeCenterY | 对象的矩形的 Y 轴中心 |  
| NSLayoutAttributeBaseline | 对象的基线 |  
| ... | ... | 

下图是常用属性的示意图：

![自动布局的属性示意图](media/15530840120043/%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E7%9A%84%E5%B1%9E%E6%80%A7%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

#### 左右两侧关系

约束方程中左右两侧的关系使用 NSLayoutRelation 枚举值来表示，具体枚举值如下：

| NSLayoutRelation 枚举值 | 说明 |
| :-: | :-: |
| NSLayoutRelationLessThanOrEqual | 约束要求第一个属性小于或等于修改后的第二个属性。 |
| NSLayoutRelationEqual | 约束要求第一个属性与修改后的第二个属性完全相等。 |
| NSLayoutRelationGreaterThanOrEqual | 约束要求第一个属性大于或等于修改后的第二个属性。 |

#### 创建约束

使用纯代码方式创建约束时，可以有三种选择：

- 使用布局锚点
- 使用 NSLayoutConstraint 类
- 使用可视化格式语言（ Visual Format Language）

##### NSLayoutConstraint 类

NSLayoutConstraint 类是 iOS 6.0 推出的类，用来创建约束。

使用 NSLayoutConstraint 类创建每一个约束，但是会书写大量的代码，通常难以阅读。此外，编译器不会对约束执行任何静态分析。所以可能会创建无效约束。这些无效约束可能在运行时抛出异常。

虽然 Apple 提供的 NSLayoutConstraint 不太好使用，但是好在有第三方框架 Masonry，它将 NSLayoutConstraint 类进行了封装，方便开发者使用。

##### 可视化格式语言

可视化格式语言（Visual Format Language）即 VFL 语言，是 Apple 为了简化自动布局的编码而推出的抽象语言（不推荐使用）。

可视化格式语言允许使用类似字符串的表达式来定义约束。 这提供了约束的视觉描述性表示。 可视化格式语言具有以下优点和缺点：

- 自动布局使用可视化格式语言将约束打印到控制台；因此，调试消息看起来与用于创建约束的代码非常相似。

- 可视化格式语言允许使用非常紧凑的表达式一次创建多个约束。

- 可视化格式语言仅创建有效约束。

- 无法使用可视格式语言创建某些约束，例如宽高比。

- 编译器不以任何方式验证字符串。 只能通过运行时测试发现错误。

> 🔥 **提示**
>
> 可视化格式语言具体用法参考官方文档： 📚 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1)。

## 视图布局的技巧

下面是一些有效管理布局的技巧：

- **使用自动布局。**

    使用自动布局创建的约束是一种灵活而简单的方法，可以将内容放置在不同的屏幕大小上。

- **记得在添加或删除视图时更新约束。**

    如果动态添加或删除视图，请记住更新相应的约束。

- **在展示视图控制器的视图的动画时暂时移除约束。**

    当使用 Core Animation 动画化视图时，在动画的持续时间内移除约束，并在动画完成后将约束添加回来。如果视图的位置或大小在动画中发生了变化，记住更新约束。

    > 🔥 **提示**
    >
    > 相比自动布局，使用视图的 frame 值确定视图的位置时性能最好。但是 frame 在适配不同的屏幕时，使用 frmae 非常影响开发效率，所以还是要根据具体开发合理选择。

