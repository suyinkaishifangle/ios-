# Objective-C 协议和代理模式

## 协议

首先要理解什么是协议。协议用于定义一种规范，采用协议的类就必须要遵守这个规范。Objective-C 中的协议相当于部分编程语言（如：Java）中的接口。

一个类如果采用了某个协议，那么这个类就要遵守这个协议，即实现协议中要求方法。

既然采用协议可能会有额外的工作量，那么为什么要创建或采用协议呢？因为本质上，协议类似于其他编程语言中的多继承，在 Objective-C 中，类是单继承的，即一个类只能有一个父类。然而某些场景需要一些额外的功能需要「继承额外的类」（可以简单这样理解，但是并不是继承），协议就是实现这样的需求。采用协议就可以给这个类一些额外的功能，从而使该类可以适用不同的使用场景。

协议包含「正式协议」和「非正式协议」，一般说的协议是指正式协议（非正式协议已经被替换成带有 `@optional` 关键字的正式协议）。正式协议要求在类的 @interface 声明中列出协议的名称，并且类也要遵守该协议（也就是要实现该协议的所有方法），否则编译器会生成警告。

### 协议的声明

协议是公共的声明，如果只是某个类使用，常做的就是写在某个类中来声明一个协议，这个类叫「声明协议的类」。如果是多个类都是用同一个协议，建议创建一个 Protocol 文件，在这个文件中声明协议。

在 Xcode 10 中创建 Protocol 文件的方法之一：

 ⚙️ **File ➤ New ➤ File... ➤ Source ➤ Objective-C File ➤ Next ➤ File type：Protocol**。

其中最后一步的 `File` 是协议名，`class` 一栏禁用状态，即不需要使用。然后 Xcode 会自动生成一个 `协议名.h` 的文件，这个文件中就是协议的声明。

声明协议使用 `@protocol` 关键字，声明协议的语法如下：

```Objective-C
@protocol 协议名 <父协议>
@required
// 方法1
...
@optional
// 方法2
...
@end
```

协议的命名和类的命名规则一致。协议中的所有方法都是公开的访问权限。

`@required` 关键字后面的方法是采用协议的类必须实现的方法。
`@optional` 关键字后面的方法是采用协议的类选择实现的方法。

> ⚠️ 注意
>
> - 协议名称必须要唯一。
> - 协议不能定义成员变量。
> - 如果方法没指明是 `@required` 还是 `@optional`，则默认是 `@required`。
> - 协议中的方法可以是实例方法，也可以是类方法。但是只是方法的声明，没有具体的实现过程。
> - Cocoa 中「NSObject 协议」是所有协议的根协议，就像「NSObject 类」是所有类的父类一样。子协议继承父协议将会获得父协议中的所有方法。
> - 协议可以继承父协议，这点与类继承父类相似。但是协议可以继承多个协议，而类只能继承一个类。继承多个协议时，父协议之间使用 `,` 号隔开。

### 采用协议

#### 类采用协议

要区分哪个是「声明协议的类」，哪个是「采用协议的类」。上面提到的声明协议，就是在「声明协议的类」中进行的。声明了协议之后，其他的类需要采用这个协议，那么采用这个协议的类叫做「采用协议的类」。

某个类要采用一个或多个协议，可以在该类的声明部分中列出采用的协议的名称，并使用 `<>` 号包括起来。语法如下：

```Objective-C
// 在类的声明中采用协议
@interface 类名 : 父类名 <协议名>
...
@end
```

或者在类扩展中列出采用的协议的名称，并使用 `<>` 号包括起来。语法如下：

```Objective-C
// 在类的类扩展中采用协议
@interface 类名 () <协议名>
...
@end
```

无论是在类的声明中列出采用的协议，还是在类扩展中列出采用的协议，都是相同的作用。一般开发中，常把类采用的协议列在类的类扩展中。

#### 数据类型采用协议

除了类，可以采用协议，数据类型同样也可以采用协议。可以为成员变量或方法参数指定协议名称。一般会在代理模式中的委托方对象中设置一个采用协议的 id 类型的属性，这个属性用来指定代理方对象，例如：

```Objective-C
@property (nonatomic, weak) id<协议名> delegate;
```

## 代理模式

代理（delegate，也叫委托）模式是某个对象指定另一个对象处理某些特定任务的设计模式。在 Obejective-C 中对代理模式支持很友好，其中的协议就是为了方便的使用代理模式。

前面提到，协议体现的是一种规范。声明协议的类把协议中方法的具体实现交给了采用协议的类。这样可以让类具有更好的通用性。

举 iOS 开发中最常用到的 UITableView 类的例子来说明。这个 UITableView 对象只实现最通用的表格行为，具体到表格的表格包含多少个节（section），每个节有多少行，每一行的数据从哪里来，每一行的外观是什么等等，都是由采用  UITableViewDataSource 协议的类的对象来提供。换成专业术语来说，表格对象将数据处理等动作委托给采用 UITableViewDataSource 协议的对象负责处理。并且，用户单击表格行、选择表格行等各种事件都不是由 UITableView 对象负责处理，而是委托给采用了 UITableViewDelegate 协议的对象负责处理。

### 组成部分

代理模式中主要有三个组成部分：

- 协议：用来指定代理双方必须做什么，可以做什么。
- 委托方：根据协议，提出需求并指定谁成为代理方。
- 代理方：根据协议，完成委托方的需求。

> ⚠️ 注意
>
> 一个对象可以作为不同委托方的代理方，一个委托方也指定多个代理方（但是一个代理属性只能指定一个代理对象，如果一个委托方有多个代理属性，所以就可以指定多个代理方）。

三者的关系如下图：

![代理模式的三个组成部分](media/15095863803172/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%89%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png)

### 实际应用

这里分别以类 A 和类 B 作为委托方和代理方，协议为 C。

1. 首先在类 A 中声明协议 C（假如只有类 A 使用协议 C，所以这里将协议声明在类 A 的文件中）

```Objective-C
// A.h
#import <Foundation/Foundation.h>

// 协议 C
@protocol C <NSObject>

@required
- (void)method1;

@optional
- (void)method2;

@end

@interface A : NSObject
// 设置属性，用来指定代理对象
@property (nonatomic, weak) id<C> delegete;

@end
```

2. 在类 A 的实现文件中调用方法判断类代理方是否实现协议中的方法

```Objective-C
// A.m
#import "A.h"

@implementation A

- (void)method {    
    if([self.delegate respondsToSelector:@selector(methed1)]) {
        [self.delegate methed1];
    }
}

@end
```

3. 然后在类 B 中采用协议 C 并且实现协议中的必要方法 

```Objective-C
// B.h
#import <Foundation/Foundation.h>
#import "A.h"

@interface B : NSObject <C>

...

@end


// B.m
#import "B.h"

@implementation B

- (void)method1 {    
    ...
}

@end
```

上面作为委托方的类 A 需要自己调用自己的 methed 方法来触发整个代理流程，这里代码写的不够严谨。其中 `respondsToSelector:` 方法是 NSObject 协议中必须实现的方法，这就是为什么 NSObject 是所有协议的根协议的原因之一。

那么这个 `respondsToSelector:` 的作用是什么呢？这个方法返回一个布尔值，如果调用者实现或继承了一个能够响应选择器中的方法，则为 `YES`，否则为 `NO`。（即用来判断代理方是否实现了协议中的必要方法）

### 内存管理

在 iOS 中代理的本质就是代理方对象内存的传递。在委托方中设置了一个 id 类型的指针，这个指针指向代理方对象，于是就能够在委托方对象中操作代理方对象（比如向代理方对象发送某些消息）。

这个 id 类型的指针**必须使用 `weak` 关键字，不能使用 `strong` 或者 `assgin` 关键字**。

首先，`strong` 关键字表示该属性是强引用，表示委托方对象持有代理方对象。如果项目中委托方对象是在代理方对象中创建的（即代理方对象持有委托方对象），那么就会变成委托方对象和代理方对象相互强引用，造成**循环引用**的问题。如下图：

![代理中的循环引用对比](media/15095863803172/%E4%BB%A3%E7%90%86%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%AF%B9%E6%AF%94.png)

其次，虽然 `weak` 和 `assign` 关键字都是修饰该指针是一种「非拥有关系」的指针，通过这两种修饰符修饰的指针变量，都不会改变指针指向对象的引用计数器的值。但是在一个对象被释放后，`weak` 会自动将指针指向 `nil`，而 `assign` 则不会。在 iOS 中，向 `nil` 发送任何消息都不会导致崩溃，而向 `assign` 修饰的指针发送消息会导致野指针错误，引发程序崩溃。










