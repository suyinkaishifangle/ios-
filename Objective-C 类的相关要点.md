# Objective-C 类的相关要点

##  部分常见术语

- **框架（framework）**

    框架是一种把头文件、库、图片、声音等内容聚集在一个独立单元中的集合体。如 Cocoa 是一个框架集，它的组成部分有 Foundation 框架和 Application Kit（也称为 AppKit）框架等。

    每个框架都是一个重要的技术集合，通常包含数十个甚至上百个头文件。每个框架都有一个主文件，它包含了框架内所有的头文件。使用 `#import` 命令包含这个主头文件，就可以访问框架中的所有功能。

    > ⚠️ **`#import` 和 `#include` 以及引号和尖括号的区别**
    > 
    > 无论是 `#import` 还是 `#include` 本质上的原理都是将对应头文件的内容复制粘贴到实现文件中。`#import` 能够保证一个头文件只被引用一次，无论此命令后的头文件出现了多少次，例如：C 引用了 B，B 引用了 A，而如果在 C 的头文件中也引用 A，最终 C 也只会引用一次 A。而 `#include` 则不行。
    > 
    > 导入头文件有两种方法：使用引号 `""` 或者尖括号 `<>`。带尖括号的语句用于导入系统头文件，这个头文件针对项目来说是只读的，因为它属于系统；而带引号的语句则说明导入的是本地的头文件，参与开发的人员都能够编辑它。
    
- **标识符**

    所谓标识符，就是用于给程序中变量、类、方法命名的符号。Objective-C 的标识符有以下几个规则（基本和其他编程语言相同），Objective-C 语言是区分大小写的编程语言，所以标识符是区分大小写的。

    - 标识符可以由字母、数字、下划线（_）和美元符（\$）组成，但不能以数字开头（开发中一般不会使用 \$ 符号）。  
    
    - 标识符不能是 Objective-C 的关键字，可以包含关键字，**但是不能以关键字作为驼峰命名法的开头**。
    
        例如：因为 new 是关键字，使用 `newPassword` 这个标识符，Xcode 会报错。而使用 `newpassword` 这个标识符则不会。
        
    - 标识符不能包含空格。 

- **封装**（encapsulation）：将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。

- **继承**（inheritance）：一个对象直接使用另一对象的属性和方法，一般是子类继承父类的属性和方法。

- **多态**（polyorphism）：由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应。

- **类**（class）：是一种表示对象类型的结构体，类名首字母一般大写。

- **对象**（object）：是一种包含值和指向其类的隐藏指针的结构体。指向对象的变量通常不需要首字母大写。

- **实例**（instance）：是「对象」的另一种称呼。

- **成员变量**（instance variable）：就是对象中的变量，也叫成员变量。

- **消息**（message）：是对象可以执行的操作，用于通知对象去做什么。

- **方法**（method）：是为响应「消息」而运行的代码，和「函数」类似。

- **接口**（interface）：是类为对象提供的特性描述，例如类中可以使用哪些方法和属性。

- **实现**（implementation）：是使接口能正常工作的代码。

## @interface 接口部分

Objective-C 中接口部分包括对成员变量、方法以及属性的声明。可以在 .h 文件中，使用 `@interface` 声明成员变量、方法以及属性，也可以在 .m 文件中使用 `@interface` 声明这些属性和成员变量（即使用类扩展），这里一般指的是 .h 文件中的 `@interface` 部分。在 .h 文件中声明的这些成员变量、方法以及属性，是为了让外部其他的类能够调用他们。

![@interface 接口部分](media/15095358850320/@interface%20%E6%8E%A5%E5%8F%A3%E9%83%A8%E5%88%86.png)

如果没有定义成员变量，那么可以省略花括号。使用 `-` 方法标识符创建`实例方法（对象方法）`，只有对象才能调用；使用 `+` 方法标识符创建`类方法`，直接用类名调用。「实例方法」即接受消息的对象是「对象」，「类方法」接受消息的对象是「类」。注意方法名称包括 `:` 符号，上述 .h 文件中的第三个方法名称是：`method_3:width:height:`

> 🔥 **中缀符**
> 
> Objective-C 中的方法名称及及其参数都是合在一起的。这种语法技术称为「中缀符（infix notation）」。例如：` [string setStringValue:@"Hello World" color:blackColor];` 中，`setStringValue:color:` 是方法的名称（包括冒号），而 `@"Hello World"` 和 `blackColor` 是具体的参数。
> 
> 这种语法和 C 语言不同，在 C 语言中调用函数时，是把所有的参数都放在函数名称之后。虽然 Objective-C 的方法看起来有些古怪，但是它的代码可读性更强。

从 Xcode 4 开始，Objective-C 建议成员变量名以下划线（_）开头。所以上面的成员变量最好写成下面的方式。

```Objective-C
NSString *_name;
NSUInteger _number;
```

- 成员变量的访问控制符的类型

    - `@private`：当前类访问权限。
    - `@package`：同一映像访问权限。同一映像是指在编译后生成的同一个框架或同一个执行文件。
    - `@protected`：当前类和子类访问权限。
    - `@pubilc`：公共访问权限。

    > ⚠️ **注意**
    > 
    > 1. Objective-C 中在 .h 文件内声明的成员变量类型默认是 `protected`(保护型)。直接访问成员变量和 C 语言相同，使用 `->` 符号，而不是使用访问属性的点表达式 `.`。点表达式其实是调用 setter 或 getter 方法，不能直接访问成员变量。
    > 2. 虽然 Objective-C 有四种访问控制符，但是在实际开发中常用属性来声明成员变量，并且根据属性声明的位置和属性修饰符来控制成员变量的访问权限，几乎不会使用访问控制符。

## @implementation 实现部分

实现部分的代码一般写在 .m 文件中，包含方法的具体实现。

```Objective-C
@implementation Stu     
- (void)method_1 {  //无参数的方法

}
- (NSString *)method_2:(NSString *)setName {  //有参数的方法
    ... // 代码
}
+ (void)method_3:(id)sender width:(NSInteger)x hight:(NSInteger)y {
    ... // 代码
}
@end
```

> ⚠️ **注意**
> 
> 虽然不需要被其他类调用的方法没有在 .h 文件中声明，但是也可以被外部调用。Objective-C 不存在正真的私有方法，也无法把某个方法标记为私有方法。这是 Objective-C 动态本质的副作用。
    
## 对象创建和初始化

创建一个对象包括为其分配内存空间和初始化该内存区域。
    
```Objective-C 
className *object;
object = [[className alloc] init];   // 方式一
object = [className new];            // 方式二
[object method:value1 width:value2 hight:value3] // 向对象发送调用方法的消息
```
    
> 🔥 **提示**
>
> 使用「方式一」或者「方式二」的方法是等价的，不过 Cocoa 的惯例是使用 `alloc/init` 而不使用 `new`。   
    
通知对象执行某种操作称为**发送消息**（也叫「**调用方法**」）。
向对象（类）发送消息的过程实际就是调用对象（类）方法的过程，也就是 C 语言中的调用函数。

- 分配内存空间（alloc）

    从操作系统获得一块内存，并将其指定为存放对象的成员变量的位置。向某个类发送 `alloc` 消息，就能为类分配一块足够大的内存，以存放该类的全部成员变量。

- 初始化（init）

    分配完内存还需要对这个内存区域全部初始化为 0，否则将会产生由于未初始化内存而引起的各种随机 bug。所有的BOOL 类型变量被初始化为 `NO`，所有的 int 类型变量被初始化为 `0`，所有的 float 类型变量被初始化为 `0.0`，所有的指针被初始化为 `nil`，等等。
    
> ⚠️ **为什么 `object = [[className alloc] init];` 而不是 `object = [className alloc]; [object init];`**
> 
> 因为初始化返回的对象可能和分配的对象不同，虽然这种情况很奇怪，但它的确会发生。所以调用这种 `[[className alloc] init];` 嵌套技术非常重要。
    
## 继承  

首先需要了解什么是父类，什么是子类：

- 父类：继承的类，也叫超类。Objective-C 中所有类的父类都是 `NSObject`。
- 子类：执行继承的类，也叫孩子类。

「继承」可以定义一个具有父类所有功能的新类。
    
```Objective-C
@interface NSString : NSObject   // NSString 类继承自 NSObject
    ...
@end
```
    
> ⚠️ **注意**
> 
> - Objective-C 不支持多继承，在 Objective-C 中，一个类只能继承一个父类。
> - 继承能够获取父类的全部属性，子类不必再声明父类中的成员变量和方法。
> - 方法调度时优先调用本类中方法，如果找不到则调用其父类中的方法，如果父类中也找不到，就到父类的父类中调用，依此类推。
> - 父类中的方法在子类中重新定义的过程叫「重写（override）」。
> - 如果在子类中要调用父类的方法，则使用 `super` 关键字。
> - 如果子类中定义了和父类相同的属性，那么编译器会警告，如果想要在子类中重写该属性的 setter 和 getter 方法，需要使用关键字 `@dynamic`；
 
## 构造和析构

- 构造函数

    在 Objective-C 中的构造函数都是以 `init` 开头的。构造函数主要用来在创建对象时初始化对象，在 Objective-C 手动调用。
    
    示例代码：

    ```Objective-C 
    - (instancetype)init;  //不带参数的构造函数
    - (instancetype)initWithAge:(int)age name:(NSString *)name { //带参数的构造函数
        ...
    }  
    ```

- 析构函数

    `dealloc` 可以认为是析构函数，在 Objective-C 中自动调用，用来释放该对象所占用的内存空间。
    
## 重载和重写

- **重载（overload）**

    函数名相同，函数的参数列表不同(包括参数个数和参数类型)，至于返回类型可同可不同。重载既可以发生在同一个类的不同函数之间，也可发生在父类子类的继承关系之间，其中发生在父类子类之间时要注意与重写区分开。

    Objective-C 支持参数个数不同的函数重载，因为 Objective-C 是基于中缀符的方法名，所以 Objective-C 没有真正意义上的重载。

    示例代码：
    
    ```Objective-C
    // Objective-C 中的重载
    - (void)test:(int)one;
    - (void)test:(int)one andTwo:(int)two;
    
    /* Objective-C 可以通过参数个数实现函数重载，但是如果参数相同，
       无论参数和返回值类型相同与否都无法编译通过。 */
       
    // 下面的定义无法通过 Xcode 的编译
    - (void)test:(int)one;
    - (int)test:(float)one;
    ```

- **重写（override）**

    发生于父类和子类之间，如果子类不想继承和使用父类的方法，通过重新编写同一个函数来实现对父类中同一个函数的覆盖，因此又叫「函数覆盖」。注意重写的函数必须和父类一模一样，包括函数名、参数个数和类型以及返回值，只是重写了函数的实现，这也是和「重载」区分开的关键。

## 复合

把多个对象组合到一起，形成一个新的类。只有对象之间的组合才能叫「复合」，如果是基本类型的组合不能叫复合。如下代码：

```Objective-C
@interface Student: NSObject {
    NSString *name;  
    NSNumber *number;     // NSString 和 NSNumber 都是对象类型。
}
```

## 深浅复制

## 类型强制转换

类型转换运算符能够将一个类型的变量转换为另外一个类型。类型转换的运算符是圆括号，具体用法是：`(type *)variable`，表示将变量 variable 强制转换为 type 类型，无论 variable 变量之前是什么类型。不过要注意，这种强制类型转换值时改变了该指针变量的编译时类型，而该变量所指向对象的实际类型并不会发生任何改变。所以开发者需要根据实际情况进行类型强制转换，否则可能会引发程序崩溃。

在执行强制转换之前，可以使用 `isKindOfClass:` 和 `isSubclassOfClass:` 方法判断指针变量实际指向的对象是否为某个类、某个子类的实例。这两个方法都会返回一个 BOOL 类型，用于表明该变量实际指向的对象类型是否和参数一中传入的类相同。