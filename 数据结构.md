# 数据结构

-------
[toc]

## 课程结构导图
![课程结构导图](media/15041041474627/%E8%AF%BE%E7%A8%8B%E7%BB%93%E6%9E%84%E5%AF%BC%E5%9B%BE.png)

## 1. 基本概念和术语
### 1.1 解决实际问题
解决实际问题的五个步骤：
1. 从实际问题出发，抽象出数学模型
2. 设计出解决该数学模型的算法(这门课程学习的目的)
3. 编出程序
4. 调试修改
5. 解决问题
> 算法的描述：算法并不需要编程基础
>
>   - 自然语言
>   - 流程图
>   - [伪代码](http://baike.baidu.com/link?url=vZ_0zWxxLxSuLz5OjhAup7n961SDFE-ePuJ96rc5bsNHIGFysrIehuGYkh1XAxntWmfZdb99j65BqqzdmU1ZAWlXy_H5nWizTH0XrsPjS8AZBozVu81Tfa-jCBrnyrsp)

### 1.2 几个重要的术语
- 数据(Data)
能被计算机程序处理的符号总称
- **数据元素(Data Element):**
数据不可分割的最小基本单位，又称为：**结点、顶点、记录、元素**
- **数据结构(Data Structure):**
彼此之间存在一种或多种特定关系的元素集合
- 数据对象：
具有相同性质的数据集合

### 1.3 数据结构的基本类型
- 集合结构：没有特定关系
- 线性结构：一对一
- 树形结构：一对多 
- 图形结构：多对多

### 1.4 数据结构的组成
三部分：

- 逻辑结构
- 物理结构
- 运算

1. 逻辑结构(不依赖计算机而存在)：
其实质是描述数据元素之间某种特定的逻辑关系，通常用`B=(K,R)`来表示，K表示数据元素的有限集，R表示关系的有限集
2. **物理结构：**
其实质是数据的逻辑结构在计算机存储器上实现，目标:1.存储数据元素，2.体现关系
* **常用的存储方法：**
  1. **顺序存储法**：
  逻辑上相邻的元素物理位置上也相邻
  2. **链式存储法**：
  将每个存储单元一分为二，前一个存放结点的数据（数据域），后一个存放后续结点的首地址（地址域）
  3. 索引存储法：
  采用结点的索引号来存储结点的方法
  4. **哈希存储法(散列法)**：
利用结点的关键值来确定结点地址的方法，其关键是寻求一个恰当的[哈希函数](http://baike.baidu.com/link?url=ueU3k1Lhqlutc9q_k30m3sqAXwVUf7BaGOAUxuoQK00aYaEgB6woNWC7OsA9L1Q25UNWB74Az5_5WNlMc1c5i_0k4EYeYDFyw3COqWPnZKogyWqfLXWZOea3X4mmK8dK)

### 1.5 算法及其评价
- 算法的定义：解决某一类特定问题的有限运算序列
- 算法的特征：
   * 有穷性
   * 确定性
   * 可行性
   * 输入
   * 输出
- 算法评价标准
   * 正确性
   * 可读性
   * 健壮性
   * 高效性（时间复杂度和空间复杂度）

### 1.6 时间复杂度计算
- 几个重要的术语

1. 运行时间：
一个算法在计算机上运行所耗费的时间，通常用时间复杂度恒量
2. **频度：**
一个算法中基本语句重复执行的`次数`，通常用**`f(n)`**表示
3. **时间复杂度：**
一个算法中基本语句重复执行的次数的数量级，通常用**`T(n)`**表示

- 时间复杂度的计算
 **计算公式：T(n) = O(f(n))**
 > 常用的时间复杂度有：
 * O(1)：常量阶
 * O(n)：线性阶
 * O(n<sup>2</sup>)：平方阶
 * O(n<sup>3</sup>)：立方阶
 * O(lg<sup>n</sup>)：对数阶
 
 > **注意：** 在时间复杂度中，log(2,n)(以2为底)与lg(n)(以10为底)是等价的

例题：

```
1.{
    x = x + 1;  //仅有一个基本语句
}
计算：f(n) = 1
     T(n) = O(f(n)) = O(1)

2.{
    for (i = 1; i <= 100; i++)
        x = x + 1;  //仅有一个基本语句，但执行了100次
}
计算：f(n) = 100  //常量
     T(n) = O(f(n)) = O(1)

3.{
    for (i = 1; i <= n; i++)
        x++;
}
计算：f(n) = n
     T(n) = O(f(n)) = O(n)

4.{
    for (i = 1; i <= n; i++)
        for (j = 1; j <= m; j++)
            x++;    //仅有一个基本语句，但是执行了n*m次，属于平方阶
}
计算：f(n) = nm
     T(n) = O(f(n)) = O(nm)

5.{
    for (i = 1; i <= n; i++)
       {
           y = y + 1;  //两个基本语句，这个执行n次
           for (j = 0; j <= (2*n); j++)
               x = x + 1;  //两个基本语句，这个执行2n^2+n次
       }
}
计算：f(n1) = n   f(n2) = n[(2*n)+1]
     f(n) = f(n1) + f(n2) = 2n^2+2n  //多个基本语句等于每个频度相加
     T(n) = O(n^2)   //计算只取最高阶的时间复杂度
6.{
    for (i = 1; i <= n; i++)
        for (j = i, k = 1; k <= j; k++)
            x++;   //一个基本语句，执行n的阶乘次
}     
计算：f(n) = n(n+1)/2 = 1/2n^2 + 1/2
     T(n) = O(n^2)
7.{
   i = 1;  // 这个基本语句只执行1次
   while(i <= n)
       i = i * 3;  //这个基本语句，如果一直执行就是3的指数函数
                   //所以是3^f(n) <= n是结束条件f(n) = lgn
计算：f(n) = lgn
     T(n) = O(lgn)
```
## 2. 线性表
### 2.1 线性表的逻辑结构
- 线性表的定义
由n个具有相同属性的数据元素组成的有限序列
- 线性表的表示
![线性表的表示](media/15041041474627/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E8%A1%A8%E7%A4%BA.png)

> 注意：
> 1. n表示线性表的长度，若n=0，说明线性表位空表
> 2. i表示数据元素在线性表中的位置
> 3. 除了a<sub>1</sub>和a<sub>n</sub>外，其余元素都有直接前驱和直接后继，a<sub>1</sub>没有前驱，a<sub>n</sub>没有后继

### 2.2 线性表的物理结构

#### 2.2.1 顺序存储结构的线性表(顺序表)

* 顺序表的实现
定义一个数组，自动分配n个内存单元
![顺序表的实现](media/15041041474627/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0.png)

    > 地址计算公式：Loc(a<sub>i</sub>) = Loc(a<sub>1</sub>) + (i - 1)l

* 顺序表示的特点
  1. 简单容易实现
  2. 对数据元素的访问速度快
  3. 插入和删除不方便(需要大量移动数据元素)

* 顺序表操作的算法实现
> **方法：**
> 1. 画图分析:把抽象的问题具体化(即假设值)
> 2. 具体化:具体化在转化为算法时可以用来验证

- 顺序表指定位置插入元素
在一个长度为n的顺序表中的第k个位置插入一个新元素x,顺序表由数组a[n]表示
算法:列出已知条件，首先作图。
![指定位置插入](media/15041041474627/%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5.png)
然后根据图来写算法，写算法用假设验证是否正确

  ``` cpp
int insert(int a[], int n, int x, int k)
{  
        int i;
        for(i = n; i >= k-1; i--){
            a[i+1] = a[i];
        a[k-1] = x;
        n++;    
}
  ```

- 顺序表指定位置删除元素
在一个长度为n的顺序表中的第k个位置删除这个元素，顺序表由a[n]表示
算法:图略，写出算法：
  
  ``` cpp
int Delete(int a[], int n, int k)
{ 
        int i;
        for(i = k-1; i <= n-2; i++)
            a[i] = a[i+1];  
        n--;  
}
  ```

- 有序顺序表的有序插入
在长度为n的有序顺序表中，要求插入x，使插入后任然有序，顺序表用a[n]表示
算法:

  ``` cpp
int sortInsert(int a[], int n, int x)
{
        int k = 0, i;
        while(x > a[k])
            k++;
        for(i = n; i > k; i--)
            a[i] = a[i-1];
        a[i] = x;
        n++;
}
  ```

#### 2.2.2 链式存储结构的线性表
- 链表的定义：
链表是一种动态分配存储空间的数据结构，他不需要一组连续的存储空间，而需要一组离散的甚至是任意的存储空间
- 链表的分类
  1. 单链表
  * **非循环单链表**(研究这个)
  最后一个结点的指针为空(NULL)
  * 循环单链表
  2. 双链表
  * 非循环双链表
  * 循环双链表
* **单链表**(重点)
单链表定义
![单链表结点](media/15041041474627/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9.png)
 
- 单链表的两种结构
1. 不带头结点
2. 带头结点(更方便)
一般在单链表的第一个结点之前附设一个结点，成为**头结点**

- 单链表结点信息的引用
1. **头结点**
在首元结点之前的一个结点，头结点的指针域指向首元结点的数据域，头结点的数据域可以不储存任何信息，也可以存储整个链表的数据域类型相同的其他附加信息，如：当整个链表的数据域类型为整数时，头结点你的数据域可以存放线性表的长度
2. **首元结点**
链表中储存第一个数据元素a<sub>1</sub>的结点
3. **头指针**
指向链表中第一个结点的指针，如果链表有头结点，则指向头结点，如果链表没有头结点，则指向首元结点
![单链表](media/15041041474627/%E5%8D%95%E9%93%BE%E8%A1%A8.png)

- 单链表的结点描述
算法:
  
  ``` cpp
//struct node 的作用和int、float一样，是数据类型
struct node   //node 是结构体名
{
        类型 data;
        struct node *next;   //next 的指针类型是 struct node
};
typedef struct node NODE;  //typedef 是用来取别名的关键字，表示 struct node = NODE
NODE *p;    //p 的指针类型是 struct node
  ```
- 单链表的建立算法
算法:
  
  ``` cpp
creat()
{
        NODE *head, *p, *s;
        int x, cycle = 1;
        head = (NODE*)malloc(sizeof(NODE));  //创建头结点，最好都创建
        head -> next = NULL;
        p = head;
        while(cycle)
        {
            print("请输入一个整数（输入0则停止输入）:\n");
            scanf("%d", &x);
            if(x != 0)
            {
                s = (NODE*)malloc(sizeof(NODE));
                s -> data = x;
                s -> next = p -> next;
                p -> next = s;
                p = p -> next;
            }
            else cycle = 0;
        }
}
  ```

- 单链表结点插入描述
  
  ``` cpp
// s 表示指向新建结点的指针，p 表示指向插入结点直接前驱的指针
NODE *s, *p;
s = (NODE*)malloc(sizeof(NODE));
s -> data = x;
s -> next = p -> next;
p -> next = s;
  ```

- 单链表结点删除描述
 
  ``` cpp
// s 表示指向要删除结点的指针，p 表示指向要删除结点直接前驱的指针
NODE *s, *p;
s = p -> next;
p -> next = s -> next;
free(s);
  ```

- 单链表结点的查找算法

1. 按位置查找
查找`第i个`结点，若找到，返回其地址，否则返回空

  - 算法步骤:
  已知:查找的链表和查找的位置i
 1.定义:遍历指针p和计数变量j,使p指向头指针,j从0开始计数
 2.循环:指针p每次指向下一个结点,并且j开始计数
 3.停止:直到j计数到指定的位置,或者p指完每个结点
 4.如果j计数到指定的位置返回对应地址;如果是p指针指完每个结点,则返回空
 如图:
![按位置查找](media/15041041474627/%E6%8C%89%E4%BD%8D%E7%BD%AE%E6%9F%A5%E6%89%BE.png)

    
  - 算法描述:  
  
  ``` cpp
NODE *searchLocation(NODE *head, int i)
{
        NODE *p;
        int j = 0;
        p = head;
        while(p -> next != NULL && j < i)
        {
            p = p -> next;
            j++;
        }
        if(j == i)
            return p;
        else return NULL;
}
  ```

2. 按值查找
查找值x，若找到，返回其地址，否则返回空(默认链表中的值都不相同)

  * 算法步骤:
  已知:查找的链表和查找的值x
  1.定义:一个遍历指针p,并且使p指向头指针
  2.循环:使p遍历每一个结点,并判断该结点的指与x的关系
  3.停止:直到找到x的值或者遍历完所有结点
  4.如果找到x,则返回其地址,若遍历完所有结点,则返回空
  如图:
 ![按值查找 ](media/15041041474627/%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE%20.png)

  * 算法描述:
 
  ``` cpp
NODE *searchValue(NODE *head, int x)
{
        NODE *p;
        p = head;
        while(p -> next != NULL && p -> data != x)
            p = p -> next;
        if(p -> data == x)
            return p;
        else return NULL;
}
  ```

-  单链表结点的插入算法
 1. 按位置插入结点
在第i个位置插入结点

  - 算法步骤:
1.定义:指针p指向头结点,指针s,计数变量j初始值为0
2.循环:使指针p遍历每个结点,计数变量依次增加
3.停止:直到找到对应的**第i-1个**位置或者找完所有位置
4.判断:如果找到对应位置:生成新的结点;如果没有找到，返回相应信息
5.给新结点s的数据域赋值要插入的值x
6.将新结点s的指针域指向结点a<sub>i</sub>
7.将结点p的指针域指向新结点s
如图:
![按位置插入](media/15041041474627/%E6%8C%89%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5.png)

> **注意:**
注意最后两步不能交换顺序，否则就会丢失后面链表的地址使链表断开

  - 算法描述:
  
  ``` cpp
NODE insertLocation(NODE *head, int i, int x)
{
        NODE *p, *s;
        int j = 0;
        p = head;
        while(p -> next != NULL && j < i-1)
        {
            p = p -> next;
            j++;
        }
        if(j == i-1)
        {
            s = (NODE*)malloc(sizeof(NODE));
            s -> data = x;
            s -> next = p -> next;
            p -> next = s;
        }
        else printf("没找到第i个位置，插入失败");
}
  ```

2. 按值插入结点(有序插入结点)
在一个有序的单链表中插入新结点使其仍有序

  - 算法步骤:
1.定义:指针p指向头结点,指针s
2.创建新结点,使s指向新结点
3.将插入的值x赋值给s的数据域
4.循环:使p依次指向每个结点
5.停止:直到p指向结点的下个结点不存在或者p指向结点的下个结点的数据域小于要插入的值x，停止循环
6.s结点指向p的下个结点
7.p结点的指向s的结点
如图:
![按值插入](media/15041041474627/%E6%8C%89%E5%80%BC%E6%8F%92%E5%85%A5.png)


  - 算法描述:
  
  ``` cpp
NODE insertValueOrder(NODE *head, int x)
{
        NODE *p, *s;
        p = head;
        s = (NODE*)malloc(sizeof(NODE));
        s -> date = x;
        while(p -> next != NULL && p -> next -> date < x)
            p = p -> next;
        s -> next = p -> next;
        p -> next = s;
}
  ```

- 单链表结点的删除算法
  1. 按位置删除
删除第i个位置的结点
  - 算法步骤:
1.定义:指针p指向头结点,指针s,计数变量j等于0
2.判断:如果i等于1,head指向直接后继,释放p
2.循环:p依次指向每个结点,计数变量依次递增
3.停止:直到计数到**第i-1个**位置或者p指完所有的结点,停止循环
4.判断:如果是计数到了第i-1个位置,将这个结点断开链表并释放,否则不存在要删除的第i个结点
如图:
![按位置删除](media/15041041474627/%E6%8C%89%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4.png)

  - 算法描述:
  
  ``` cpp
deleteLocation(NODE *head, int i)
{
        NODE *p, *s;
        int j = 0;
        p = head;
        if(i == 1)
        {
            head = head -> next;
            free(p);
        }
        while(p -> next != NULL && j < i-1)
        {
            p = p -> next;
            j++;
        }
        if(j == i-1)
        {
            s = p -> next;
            if(s == NULL)
            {
                printf("没有找到第i个，删除失败");
            }
            else 
            {   
                p -> next = s -> next;
                free(s);
            }
        }
        else printf("没有找到第i个，删除失败");
}
  ```

2. 按值删除结点
删除链表中值为x的结点(默认链表中的值都不相同)

  - 算法步骤:
1.定义:指针p指向头结点,指针s
2.循环:使p依次指向每一个结点
3.停止:直到p指向的结点的下一个结点的数据域等于x或者p指完所有的结点,停止循环
4.判断:如果是p指向的结点的下一个结点的数据域等于x,将s结点孤立并且释放,否则链表中不存在值为x的结点
如图:
![按值删除](media/15041041474627/%E6%8C%89%E5%80%BC%E5%88%A0%E9%99%A4.png)

  - 算法描述:
  
  ``` cpp
deleteValue(NODE *head, int x)
{
        NODE *p, *s;
        p = head;
        while(p -> next != NULL && p -> next -> data != x)
            p = p -> next;
        if( p -> next -> data == x)
        {
            s = p -> next;
            p -> next = s -> next;
            free(s);
        }
        else printf("删除失败，不存在值为x的结点");
}
  ```


## 3. 栈
### 3.1 栈的定义及其基本操作
- 栈(stack)的定义
栈(栈也叫堆栈)是一种操作受限制的特殊线性表，只能在表尾进行操作
![栈](media/15041041474627/%E6%A0%88.png)

- 栈的基本操作

1. 压栈\入栈(push)
2. 出栈(pop)
3. 取栈顶元素(get top)

> **注意：**出栈和取栈顶元素的区别
> 栈是从栈中取走元素，出栈后该元素不在这个栈中
> 取栈顶元素是从栈中取用这个元素，但该元素还在这个栈中

### 3.2 栈的物理结构和相关算法
#### 3.2.1 顺序存储结构的栈(顺序栈)

* 顺序栈的实现
定义一个数组stack[MAX]表示栈，MAX表示栈的最大容量
![顺序栈实现](media/15041041474627/%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%AE%9E%E7%8E%B0.png)

> 上溢(overflow):超出栈的最大的存储空间
> 下溢(underflow):栈中没有元素，但是仍然取用栈中元素
> 栈为空的判断条件:top == 0
> 栈为满的判断条件:top == MAX

*  顺序栈的压栈和出栈
1. 压栈步骤
第一步:首先判断栈是否满
第二步:若不为满，将x放入top所指向的栈单元
第三步:将top加1
2. 出栈步骤
第一步:首先判断栈是否空
第二步:若不为空，将top减1
第三步:将top所指向的元素取出

#### 3.2.2 顺序栈操作的算法实现

* 压栈算法

   ``` cpp
   push(int stack[], int top, int x)
   {
        if(top == MAX)
            printf("overflow");
        else
        {
            stack[top] = x;
            top++;
        }
   }
   ```
* 出栈算法

   ``` cpp
   pop(int stack[], int top)
   {
        int y;
        if(top == 0)
        {
            printf("underflow");
            return 0;
        }
        else
        {
            top--;
            y = stack[top];
            return y;
        }
   }
   ```
* 取栈顶元素算法

   ``` cpp
   int gettop(int stack[], int top)
   {
        int y;
        if(top == 0)
        {
            printf("栈为空");
            return 0;
        }
        else
        {
            y = stack[top - 1];
            return y;
        }
   }
   ```
   
#### 3.2.3 链式存储结构的栈(链栈)

* 链栈的结构
链栈可以看做特殊的单链表，不存在上溢的情况，因为其空间大小没有限定

#### 3.2.4 链栈操作的算法实现

* 压栈算法

  ``` cpp
  push(NODE *top, int x)
  {
      NODE *p;
      p = (NODE*)malloc(sizeof(NODE));
      p -> data = x;
      p -> next = top -> next;
      top -> next = p;
  }
  ```

* 出栈算法

  ``` cpp
  NODE *pop(NODE *top)
  {
      NODE *p;
      p = top; 
      if(top == NULL)
          return NULL;
      else
      {
          top = top -> next;
          return p;
      }
  }
  ```
### 3.3 栈的应用
#### 3.3.1 栈应用于进制之间的转换

``` cpp
conversion(int x)
{
    int stack[MAX], top = 0;
    int y;
    Initstack(s);
    while(x != 0)
    {
        push(s, x % 8);
        x = x / 8;
    }
    while(top > 0)
    {
        y = stack[top];
        printf("%d", y);
        top--;
    }
}
```
#### 3.3.2 栈应用于表达式求值
- 表达式的组成结构
1. 操作数(operand)->OPND
2. 运算符(operator)->OPTR
3. 界符(`(`和`)`)运算法之间的优先关系
大于、小于、等于三者之一
按照括号、先乘除后加减的顺序判断

- 引入两个工作栈
![工作栈](media/15041041474627/%E5%B7%A5%E4%BD%9C%E6%A0%88.png)

当扫描到数字时，直接压入OPND栈；
当扫描到运算符(设为C<sub>1</sub>)时，将此运算符与OPTR栈中栈顶的运算符(设为C<sub>2</sub>)做比较
1.如果C<sub>1</sub>优先级大于C<sub>2</sub>时，将C<sub>1</sub>压栈，继续扫描
2.如果C<sub>1</sub>优先级小于C<sub>2</sub>时，将C<sub>2</sub>从栈中取出，从OPND栈中取出两个数字进行运算，将结果压入OPND栈

|步骤|OPTR栈|OPND栈|扫描字符|操作|
|:--:|:--:|:--:|:--:|:--:|
|1|\#|NULL|\#<span style="border-bottom:5px dashed red">3</span>*(7+2)#|push(OPND,'3')|
|2|\#|3|\#3<span style="border-bottom:5px dashed red">*</span>(7+2)#|push(OPTR,'*')|
|3|\#*|3|\#3*<span style="border-bottom:5px dashed red">(</span>7+2)#|push(OPTR,'(')|
|4|\#*(|3|\#3*(<span style="border-bottom:5px dashed red">7</span>+2)#|push(OPND,'7')|
|5|\#*(|3,7|\#3*(7<span style="border-bottom:5px dashed red">+</span>2)#||
|6|\#*(+|3,7|\#3*(7+<span style="border-bottom:5px dashed red">2</span>)#||
|7|\#*(+|3,7,2|\#3*(7+2<span style="border-bottom:5px dashed red">)</span>#||
|8|\#*(|3,9|\#3*(7+2)<span style="border-bottom:5px dashed red">#</span>|消去括号|
|9|\#*|3,9|\#3*(7+2)#||
|10|\#|27|\#3*(7+2)#|消去括号|

## 4. 队列
### 4.1 队列的定义及其基本操作

- 队列的定义(queue)
操作受限的特殊线性表，只能在表尾入队列，只能在表尾出队列(先进先出)
![队列](media/15041041474627/%E9%98%9F%E5%88%97.png)

- 队列的基本操作
1. 入队列(Enqueue)
2. 出队列(Delqueue)
3. 取队首元素(Getfront)
4. 计算队列长度(Length)

### 4.2 队列的物理结构

- 队列的分类
1. 非循环队列
2. 循环队列(更常用)

#### 4.2.1 顺序存储结构的队列(顺序队列)
- 非循环队列
1. 实现:
定义一个数组Queue[MAX]表示一个顺序队列，MAX表示最大长度，则队尾元素为Queue[MAX-1]
  - 队首指针(front)
  - 队尾指针(rear)
  - 入:**将rear向后一个存储空间移动**
  - 出:**将front向后一个存储空间移动**
  - 初始化:front = rear = -1
  - 判空:front = rear
  - 判满:rear = MAX - 1
- 循环对列
![循环队列](media/15041041474627/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png)

1. 引入原因:
提高存储空间的利用率
2. 实现:
定义一个数组Queue[MAX]表示一个循环队列
 - 初始化:front = rear = 0
 - 判空:front = rear
 - 判满:front = (rear + 1) % MAX (牺牲判满，牺牲最后一个单元空间)
 - 计算长度:m = (rear - front + MAX) % MAX
#### 4.2.2 循环队列操作的算法实现
- 入队列算法实现

``` cpp
Enqueue(int x, int queue[], int front, int rear)
{
    if((front == rear + 1) % MAX)
        printf("队列已满！");
    else
    {
        rear = (rear + 1) % MAX;   //不能写成rear++，因为队列是循环的，可能出现rear指向队尾，而这时不存在rear++
        queue[rear] = x;
    }
}
```

- 出队列算法实现

``` cpp
Delqueue(int queue[], int front, int rear)
{
    if(front == rear)
        printf("队列为空！");
    else
    {
        front = (front + 1) % MAX;
        return (queue[front]);
    }
}
```

- 取队首元素

``` cpp
Getfront(int queue[], int front, int rear)
{
    if(front == rear)
        return 0;
    else 
        return (queue[(front + 1)] % MAX);
}
```

####  4.2.3 链式存储结构的队列(链队列)
- 链队列的结构
![链队列](media/15041041474627/%E9%93%BE%E9%98%9F%E5%88%97.png)


- 链队列的操作算法实现
 1. 建立和入链队列算法
  - 算法步骤:
  1.建立:创建头结点并且使队首指针和队尾针指向头结点
  2.循环:现输入要入队列的值，并且将其放入建立的新结点中，将结点连上链队列中，直到输入0停止循环
  - 算法描述:
   
   ``` cpp
   creat()
   {
        NODE *front, *rear, *p;
        int x, cycle = 1;
        front = (NODE*)malloc(sizeof(NODE));
        front -> next = NULL;
        rear = front;
        while(cycle)
        {
            printf("输入要插入的值:");
            scanf("%d", &x);
            if(x != 0)
            {
                p = (NODE*)malloc(sizeof(NODE));
                p -> data = x;
                p -> next = rear -> next;
                rear ->next = p;
                rear = rear -> next;
            }
            else cycle = 0;
        }
   }
   ```
2. 出链队列算法
  - 算法步骤:
  1.定义:指针p使其指向头结点
  2.循环:孤立p指针指向的结点，并且输出该结点的值，再使p指向下一个结点，直到p指向NULL停止循环
  - 算法描述:
  
  ``` cpp
  delQueue(NODE *front, NODE *rear)
  {
        NODE *p;
        p = front;
        while(p)
        {
            front = front -> next;
            printf("%d", p -> data);
            p = front;
        }
  }
  ```
3. 计算链队列长度
  - 算法步骤
  1.定义:计数变量i，指针p，并使p指向front
  2.循环:p指向下一个结点，i依次加1，直到p指向NULL停止
  - 算法描述
 
  ``` cpp
  Length(NODE *front)
  {
        int i = 0;
        NODE *p;
        p = front -> next;
        while(p)
        {
            i++;
            p = p -> next;
        }
  }
  ```
  
## 5. 广义表和特殊矩阵
### 5.1 广义表的定义
n个数据元素组成的有限序列
L<sub>s</sub>=(a<sub>1</sub>,a<sub>2</sub>...a<sub>n</sub>)
> 注意：
> 1. n是广义表的长度，深度为所含括弧的重数
> 2. a<sub>1</sub>是表头Head，(a<sub>2</sub>,a<sub>3</sub>...a<sub>n</sub>)是表尾Tail

例:
① A=()，长度为0，深度为1，无表头，无表尾
② B=(e)，长度为1，深度为1，Head(B)=e，Tail(B)=()
③ C=(a,(b,c,d))，长度为2，深度为2，Head(C)=a，Tail(C)=((b,c,d))
④ D=((),(e),(a,(b,c,d)))，长度为3，深度为3，Head(D)=()，Tail(D)=((e),(a,(b,c,d)))
⑤ E=(a,E)，长度为2，深度无限，Head(E)=a,Tail(E)=(E)

练习题:
① 若广义表的表头和表尾都是空括号()，则广义表是？ `L=(())`
② L=((a,b),(c,d,e),(f,g))，取表头操作H(L),取表尾操作T(L)，则从L中取出元素d的操作是?    `H(T(H(T(L))))`
③ L=(x,(x,y,z,a))，从L中分离出元素y的操作是？ `H(T(H(T(L))))`

### 5.2 广义表的存储结构
广义表使用链式输入法
使用两种不同的结点相结合的存储方式:

* 表结点:标志域、表头指针域、表尾指针域
* 原子结点(不可再分):标志域、值域
![广义表](media/15041041474627/%E5%B9%BF%E4%B9%89%E8%A1%A8.png)

例:L<sub>s</sub>=(a,(x,y),((z)))的结构图
![结构图](media/15041041474627/%E7%BB%93%E6%9E%84%E5%9B%BE.png)


### 5.3 特殊矩阵的定义
对于一些特殊矩阵的结构(对称、三角、稀疏)，可以使用节省空间的方法来存储数据
### 5.4 特殊矩阵的存储结构
- 对称矩阵
例如:$\begin{equation}
A=\left[
\begin{matrix}
3&6&4&8\\\
6&2&5&7\\\
4&5&1&9\\\
8&7&9&5
\end{matrix}
\right]
\end{equation}$

1. 存放时按照先从左到右，再从上到下的方式存储对称矩阵的下半部分数据
2. 一共需要$\frac {n(n+1)}2 $个存储单元的一维数组，例如:
数组下标:|0|1|2|3|4|5|6|7|8|9|

对应数据:|3|6|2|4|5|1|8|7|9|5|
3. 求对应位置数据的公式(i表示行数,j表示列数)
$$K_1=\frac {i(i-1)}2 + (j-1) \quad \quad i>=j$$
$$K_2=\frac {j(j-1)}2 + (i-1) \quad \quad i<j$$
- 三角矩阵
例如:$\begin{equation}
A=\left[
\begin{matrix}
3&c&c&c\\\
4&2&c&c\\\
5&8&1&c\\\
1&2&7&0
\end{matrix}
\right]
\end{equation}$
1. 存放时按照先从左到右，再从上到下的方式存储三角矩阵的下半部分数据
2. 一共需要$\frac {n(n+1)}2+1 $个存储单元的一维数组，例如:
数组下标:|0|1|2|3|4|5|6|7|8|9|10|
对应数据:|3|6|2|4|5|1|8|7|9|5|c|
3. 求对应位置数据的公式(i表示行数,j表示列数)
$$K_1=\frac {i(i-1)}2 + (j-1) \quad \quad i>=j$$
$$K_2=\frac {n(n+1)}2 \quad\quad\quad\quad\quad\quad i<j$$
- 稀疏矩阵
例如:$\begin{equation}
A=\left[
\begin{matrix}
3&0&0&0&6&0\\\
0&0&0&0&16&0\\\
25&0&0&0&0&0\\\
0&0&66&0&0&0\\\
0&0&0&0&0&0\\\
0&0&0&0&0&88\\\
0&0&0&0&0&0
\end{matrix}
\right]
\end{equation}$

1. 使用三元组法存放数据
即把一个存储单元分成三份，分别存放行号、列号和数据
如:
![三元组](media/15041041474627/%E4%B8%89%E5%85%83%E7%BB%84.png)


## 6. 树和二叉树
### 6.1 树的定义及其基本操作
- 树的定义
由n个结点组成的有限集，对于任意一棵非空树：
1. 唯一一个根节点
2. 除根结点外，其余结点可分为m个不相交的子集T<sub>1</sub>、T<sub>2</sub>...T<sub>m</sub>，其中每个子集T<sub>i</sub>=(i=1,2,3...m)自身又是一个树，称为树T的子树

- 树的几个重要概念
1. 结点：树中包含的每一个数据元素
2. 结点的度：该结点拥有的子树个数
3. 树的度：树中最大的结点的度
4. 孩子结点：结点的子树的根
5. 双亲结点：B结点是A结点的孩子，则A结点是B结点的双亲
6. 兄弟结点：同一双亲的孩子结点相互为兄弟结点
7. 结点的层次：根结点为第一层
8. 树的深度：树中所有结点层次的最大值
9. 树的叶子：没有孩子的结点

- 树的基本操作
1. 初始化：Initiate(T)
2. 求根：Root(T)
3. 求双亲：Parents(T,x)
4. 求第i个孩子：Child(T,x,i)
5. 求兄弟：Lsibling(T,x) Rsibling(T,x)
6. 插入子树：Insert(T,x,i,y)
7. 删除子树：Delete(T,x,i)
8. 遍历子树：Traverse(T)
9. 置空数操作：Clear(T)

### 6.2 二叉树的定义及其基本操作

- 二叉树的定义
结点数为0或每个结点最多只有左右两个子树的树，对于任意一个二叉树都有：
  1. 每个结点的度最大不能超过2
  2. 子树有左右之分，顺序不能颠倒
 
- 二叉树的性质
  1. 一棵二叉树的第i层最多拥有2<sup>i-1</sup>个结点
  2. 一棵深度为k的二叉树，最多拥有2<sup>k</sup>-1个结点
  3. 一棵二叉树，叶子结点数为n<sub>0</sub>，度为2的结点数n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1

- 满二叉树和完全二叉树
1. 满二叉树的定义
一棵深度为k的二叉树，当且仅当它拥有第2<sup>k</sup>-1个结点时，称为**满二叉树**

2. 完全二叉树的定义
一棵深度为k，结点数为n的二叉树，当且仅当每个结点的编号与具有相同深度的满二叉树第1个～第n个结点的编号一一对应时，称为**完全二叉树**

3. **满二叉树和完全二叉树的性质**
   - 完全二叉树的叶子结点只可能出现在最外层和次外层
   - 满二叉树必定是完全二叉树，完全二叉树不一定是满二叉树
   - 一棵深度为k的完全二叉树，其结点数n至少为：2<sup>k-1</sup> ≤ n ≤ 2<sup>k</sup>-1
   - 结点数为n的满二叉树，深度为k = log<sub>2</sub>(n+1)
   - 结点数为n的完全二叉树，深度为k = (log<sub>2</sub>n)取整+1
   - 一棵按层序（从上到下，从左到右）编号的完全二叉树，结点数为n，则对于任意结点i都有：(n为结点数)
      ① 除了当i=1，i为根结点，无双亲外，其余结点i的双亲为(i/2)取整
      ② 若2i>n，则无左孩子，否则左孩子为2i
      ③ 若2i+1>n，则无右孩子，否则右孩子为2i+1
    - 一棵二叉树，总结点为n，其深度最小为(log<sub>2</sub>n)取整+1，其深度最大为n
    - 一棵n个结点的满二叉树，其叶子结点为(n+1)/2，非叶子结点为(n-1)/2
    - 一棵深度为k的完全二叉树，只有度为0和度为2的结点，其结点数为2<sup>k-1</sup>+1 ≤ n ≤ 2<sup>k</sup>-1

4. 二叉树的存储结构
 - 顺序存储法
 只适用于完全二叉树和满二叉树
 - 链式存储法
 建立一个包含左孩子域、数值域、右孩子域的结点

5. 二叉树的遍历
 - 遍历的定义
 按照某条搜索路径访问二叉树中每个结点并且每个结点仅能访问一次
 - 遍历的方法
     ① 先序遍历：先根后左再右
     ② 中序遍历：先左后根再右
     ③ 后序遍历：先左后右再根
 - 例题：
     1. 题型一：根据图形写出其不同遍历顺序的结果
     ![题型一](media/15041041474627/%E9%A2%98%E5%9E%8B%E4%B8%80.jpeg)

     写出上面两个题的先序、中序和后序的遍历顺序
     例1：先序：ABDGCEFHI&nbsp;&nbsp;&nbsp;中序：DGBAECHIF&nbsp;&nbsp;&nbsp;后序：GDBEIHFCA
     例2：先序：ABCDFE  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中序：BADFCE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后序：BFDECA
       
     2. 题型二：已知遍历方法中的两种，写出第三种遍历
     例1：已知先序为：ABCDEFGH，中序为：CDBAFEHG，求后序？
     这种题如果结点少可以根据画图来解，但是当结点数多的时候，画图就比较麻烦
     ①由先序可以知道根结点
     ②由中序可以知道在根结点左边的是左半部分，右边是右半部分
     然后依次把左半部分和右半部分再利用①②步骤判断可以得出，最后可以得出后序遍历顺序

6. 二叉树遍历的算法实现
 - 先序遍历的算法
 步骤：
p从根出发一直向左走到尽头，每经过一个结点，打印并且压栈，直到p为空
将栈顶元素取出赋给p，将p指向该结点的右孩子，若p不为空，则重复步骤①
当p为空且栈也为空的时候，结束循环
 
 ``` cpp
 preview(NODE *root)
 {
        NODE *p;
        Stack s;
        Initstack(s);
        p = root;
        while(p || !stackEmpty(s))
        {
            while(p)
            {
                printf("%d", p -> data);
                push(s,p);
                p = p -> lChild;
            }
            if(!stackEmpty(s))
            {
                pop(s,p);
                p = p -> rChild;
            }
        }
 }
 ```
 - 中序遍历的算法
 同先序，只是打印是在压栈之后
 
 ``` cpp
 midorder(NODE *root)
 {
        NODE *p;
        Stack s;
        Initstack(s);
        p = root;
        while(p || !stackEmpty(s))
        {
            while(p)
            {
                push(s,p);
                p = p -> lChild;
            }
            if(!stackEmpty(s))
            {
                pop(s,p);
                printf("%d", p -> data);
                p = p -> rChild;
            }
        }
 }
 ```
 - 层次遍历算法（从上到下，从左到右）
 不能再使用栈，只能够通过队列实现

 ``` cpp
 layerorder(NODE *root)
 {
        Queue q;
        Initiate(q);
        p = root;
        Enqueue(q, p);
        while(!EmptyQueue(q))
        {
            p = Delqueue(p);
            printf("%d", p -> data);
            if(p -> lchild)
            Enqueue(q, p -> lchild);
            if(p -> rchild)
            Enqueue(q, p -> rchild);
        }
 }
 ```
 
### 6.3 树和森林

- 树的存储结构
![输的存储结构](media/15041041474627/%E8%BE%93%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)

1. 双亲表示法
保存每一个结点的双亲
![双亲表示法](media/15041041474627/%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png)

2. 孩子表示法
保存每一个结点的孩子
![孩子表示法](media/15041041474627/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.png)

3. 孩子双亲表示法
同时保存每个结点的双亲和孩子
![孩子双亲表示法](media/15041041474627/%E5%AD%A9%E5%AD%90%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png)

4. 孩子兄弟表示法（重点）
本质：转化成为二叉树，孩子在右，兄弟在左
![孩子兄弟表示法](media/15041041474627/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.png)


### 6.4 二叉树的应用
- 二叉排序树
1. 定义：一颗非空二叉排序树，对于每个结点都有：
  - 若它的左子树为非空，则左子树中每个结点的关健值都小于该节点
  - 若它的右子树为非空，则右子树中每个结点的关健值都大于等于该节点
2. 二叉排序树的建立
给定一组关健值，用数组表示，第一个数作为二叉排序树的根，然后再取第二个关健值，与根比较，按照二叉排序树的定义存放，大于等于在右边，小于等于在左边，然后继续取关健值，先和根比较，然后如果根下面还有数，就继续比较。。。
3. 二叉排序树的查找算法

``` cpp
NODE * search(NODE *root, int x)
{
    NODE *p;
    p = root;
    while(p && p -> data != x)
    {
        if(x > p -> data)
            p = p -> rChild;
        else 
            p = p -> lChild;
    }
    if(p) //不用判断p的值，只要p不为空，出来的值肯定等于x
        return p;
    else
        return NULL;
}
```
- 哈夫曼树及其概念
![哈夫曼树](media/15041041474627/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png)

1. 结点路径：从根到结点的若干分支，如：ACDF
2. 结点路径长度：从根到结点的分支数，如F的路径长度为3
3. 树的路径长度：所有结点路径长度的和
4. 结点带权路径长度：结点权值乘以结点路径长度
5. 树的带权路径长度：结点带权路径长度的和
6. 哈夫曼树：
假设由n个权值{W<sub>1</sub>,W<sub>2</sub>...W<sub>n</sub>}构造一棵有n个叶子结点的严格二叉树[^严格二叉树]，每个叶子结点权值为W<sub>i</sub>，则WPL(树的带权路径长度和)最小的严格二叉树为哈夫曼树（结构不唯一）

- 哈夫曼树的建立
例：一组权值{3,7,8,2,5,9,4}构造一颗哈夫曼数（要求左孩子的权值大于等于右孩子的权值）
方法：从权值中始终取出最小的两个，将和添加回去，再取出最小的两个，再将和添加回去......直到最后只剩一个，就是根
> 注意：顺序一定要是先加最小的两个值，如图中红色的顺序标号

如图：
![哈夫曼树建立](media/15041041474627/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%BB%BA%E7%AB%8B.jpeg)


- 哈夫曼编码
1. 编码的类型
  - 等长编码：如A:00,B:01,C:10,D:11...(长度固定)
  - 不等长编码：如A:0,B:01,C:1,D:11...(长度相对等长编码更短，容易译码错误)
  解决：不能使一个字符的编码是另一个字符编码的前缀（一个编码完全包含在另一个编码的开头的一部分）。如上A,B。
2. 哈夫曼编码的具体过程
例：有一封电文只有ABCD四个字符，他们出现的频率分别是0.4,0.2,0.3,0.1，请给出ABCD的哈夫曼编码。
解：题目中频率都是小数，可将其扩大10倍为其权值，然后建立哈夫曼树，然后将左边路径标为1，右边路径标为0（也可以将左边路径标为0，右边路径标为1，无影响）得到对应ADCD的哈夫曼编码
![1503988130372_5](media/15041041474627/1503988130372_5.jpeg)

所以哈夫曼编码为：A:0  B:111  C:10  D:110

## 7. 图
### 7.1 图及其相关概念
- 图：由顶点和边组成，记作：G={V,E}(V:顶点有限集 E:边的有向图)
1. 有向图：图中每条边都有方向的图
2. 无向图：图中每条边都没有方向的图
3. 顶点度（仅针对无向图）：与该顶点相关联的边的数目
4. 出度（仅针对有向图）：与该顶点相关联的起点的数目
5. 入度（仅针对有向图）：与该顶点相关联的终点的数目
6. 子图：若G<sub>1</sub>={V<sub>1</sub>,E<sub>1</sub>}，G<sub>2</sub>={V<sub>2</sub>,E<sub>2</sub>}且V<sub>1</sub>$\subseteq$V<sub>2</sub>，E<sub>1</sub>$\subseteq$E<sub>2</sub>，则G<sub>1</sub>为G<sub>2</sub>的子图
7. 路径：顶点V到顶点V‘的路径
8. 简单路径：顶点不重复的路径
9. 连通（仅针对无向图）：
若两个顶点有路径，则两个顶点连通
10. 连通图（仅针对无向图）：
无向图中，如果任意两个顶点都是连通的，那么这个图叫连通图
11. 连通分量（仅针对无向图）：
非连通图的极大连通子图
例如：![1503988128181_47](media/15041041474627/1503988128181_47.jpeg)

12. 强连通（仅针对有向图）：
有一条V到V’的路径，也有一条V‘到V的路径，则两个顶点强连通
13. 强连通图（仅针对有向图）：
有向图中，如果任意两个顶点都是强连通的，那么这个图叫强连通图
14. 强连通分量（仅针对有向图）：
非强连通图的极大强连通子图
例如：![1503988127341_42](media/15041041474627/1503988127341_42.jpeg)


15. 生成树：
包含无向图中所有顶点(n个)，但仅有构成一棵树的n-1条边
> 注意：
> 1. 任意在生成树中添加一条边，必定构成环路
> 2. 任意在生成树中去掉一条边，必定变成非连通图（将某些顶点孤立）

### 7.2 图的存储
- 图的存储结构一般考虑两种：邻接矩阵表示法和邻接表表示法
![1503988122962_7](media/15041041474627/1503988122962_7.png)

1. 邻接矩阵表示法
使用矩阵来表示有向图或者无向图的边，“1”表示存在边，“0”表示不存在边（如果是有权值的图，则对应的权值表示存在边，“∞”表示不存在边）；横轴表示起点，纵轴表示终点
  - G<sub>1</sub>的邻接矩阵：
  ![1504059638774_2](media/15041041474627/1504059638774_2.png)

  - G<sub>2</sub>的邻接矩阵：
  ![1503988124052_15](media/15041041474627/1503988124052_15.png)

> 注意：
> 1.无向图的度等于值为“1”的元素个数的1/2
> 2.有向图的出度和入读等于值为“1”的元素的个数

2. 邻接表表示法
  - G<sub>1</sub>的邻接表
  ![1504059646482_10](media/15041041474627/1504059646482_10.png)

  - G<sub>2</sub>的邻接表
  ![1504059646473_3](media/15041041474627/1504059646473_3.png)

  - G<sub>2</sub>的逆邻接表
  ![1504059646475_5](media/15041041474627/1504059646475_5.png)

> 注意：
> 1.无向图的度等于结点个数的1/2
> 2.有向图G<sub>2</sub>的邻接表只能显示每个顶点的出度
> 3.有向图G<sub>2</sub>的逆邻接表只能显示每个顶点的入度

### 7.3 图的遍历
- 图遍历的定义：
从任意一点出发，按照某条搜索路径访问图中每个顶点，并且每个顶点仅被访问一次
- 遍历的类型
1. 深度优先遍历(DFS)
算法描述：
        1. 访问初始结点V，并且将V入栈
        2. 查找结点V的第一个邻接结点V‘
        3. 若V’存在，则继续执行步骤4，否则算法结束
        4. 若V’未被访问，对V’进行深度优先遍历递归（即把V’当做另一个V，然后进行步骤123）
        5. 查找结点V的V’邻接结点的下一个邻接结点，转到步骤3
2. 广度优先遍历(BFS)
算法描述：
        1. 访问初始结点V并使结点V入队列
        2. 查找结点V的第一个邻接结点V‘
        3. 当队列非空时，对V’继续执行步骤1，否则算法结束
        4. 出队列，取得队头结点U
        5. 查找结点U的第一个邻接结点w
        6. 若结点u的邻接结点W不存在，则转到步骤3；否则循环执行以下三个步骤：
1)若结点W尚未被访问，则访问结点W并标记为已访问。
2)结点W入队列
3)查找结点U的继W邻接结点后的下一个邻接结点W，转到步骤6

- 最小生成树
1. 生成树：拥有无向图中顶点n个，拥有n-1条边
2. 最小生成树：n-1条边的权值之和最小的生成树
3. 最小生成树的建立：
例：![1503988130134_2](media/15041041474627/1503988130134_2.png)

    - Prim算法（普里姆算法）
    下面表格中的步骤可知算法的步骤，Prim算法的时间复杂度为：O(n<sup>2</sup>)
    建立三个集合：U（顶点集），V-U（权集-顶点集），T<sub>E</sub>（最小生成树的边），若以A为起点:
    ![1503988127875_44](media/15041041474627/1503988127875_44.png)
    
    - Kruscal算法（克鲁斯卡尔算法）
    先列出图中的所有的边的集合:
{(A,D),(A,C),(A,B),(B,D),(B,E),(C,D),(C,F),(D,E),(D,F),(E,F)}
    再列出所有顶点的集合：
{{A},{B},{C},{D},{E},{F}}
    ![1503988125355_23](media/15041041474627/1503988125355_23.png)

    然后再将顶点集按照边的权值最小的组合成边
    ![1503988124326_19](media/15041041474627/1503988124326_19.png)


- 拓扑排序
1. DVG图（有向无环路图出）
是描述工程或系统进程的有效工具，通常不允许出现环路
2. AOV网（顶点活动网）
顶点表示一个具体的活动，“→”表示活动间的优先关系
3. 拓扑排序
 - 功能
     1. 判断工程的可行性，若AOV网出现回路，则工程永远无法结束
     2. 确定各项活动在工程中的先后顺序
 - 具体步骤（算法思想）
        1. 选择一个入度为0的顶点并输出
        2. 删除该顶点并同时删除该顶点为起点的服务
        3. 重复1，2步骤直到再也找不到一个入度为0的顶点为止
    例：![1504059646478_8](media/15041041474627/1504059646478_8.png)

    |步骤|操作描述|结果|
    |:--:|:--:|:--:|
    |<br><br><br>1|<br><br><br>根据图画出邻接表，如图|![1](media/15041041474627/1.png)|
    |<br><br>2|<br><br>将当前入度为0的两个顶点A和D压栈|![2](media/15041041474627/2.png)|
    |3|出栈栈顶元素顶点D并打印结果|D|
    |<br><br><br><br><br>4|<br><br><br><br>删除AOV网中的顶点D，并删除以D为顶点的服务c和d|![3](media/15041041474627/3.png)|
    |<br><br><br>5|<br><br><br>修改邻接表中D指向的顶点C和E的入度为1和0|![4](media/15041041474627/4.png)|
|<br><br>6|<br><br>将新的入度为0的顶点E入栈|![5](media/15041041474627/5.png)|
|7|出栈栈顶元素顶点E并打印结果|D→E|
|<br><br><br>8|<br><br><br>删除AOV网中的顶点E，并删除以E为顶点的服务g|![6](media/15041041474627/6.png)|
|<br><br><br>9|<br><br><br>修改邻接表中E指向的顶点F的入度为2|![7](media/15041041474627/7.png)|
|10|这时没有新的入度为0的结点，就继续出栈栈顶元素顶点A并打印结果|D→E→A|
|<br><br><br>11|<br><br><br>删除AOV网中的顶点A，并删除以A为顶点的服务a和b|![8](media/15041041474627/8.png)|
|<br><br><br>12|<br><br><br>修改邻接表中A指向的顶点B和C的入度为0和0|![9](media/15041041474627/9.png)|
|<br><br>13|<br><br>将新的入度为0的顶点B和C入栈|![10](media/15041041474627/10.png)|
|14|出栈栈顶元素顶点C并打印结果|D→E→A→C|
|<br><br>15|<br><br>删除AOV网中的顶点C，并删除以C为顶点的服务f|![11](media/15041041474627/11.png)| 
|<br><br><br>16|<br><br><br>修改邻接表中C指向的顶点F的入度1|![12](media/15041041474627/12.png)|
|17|这时没有新的入度为0的结点<br>就继续出栈栈顶元素顶点B并打印结果|D→E→A→C→B|
|18|删除AOV网中的顶点B<br>并删除以B为顶点的服务e|![13](media/15041041474627/13.png)|
|<br><br><br>19|<br><br><br>修改邻接表中B指向的顶点F的入度0|![14](media/15041041474627/14.png)|
|<br><br>20|<br><br>将新的入度为0的顶点F入栈|![15](media/15041041474627/15.png)|
|21|出栈栈顶元素顶点F并打印结果|D→E→A→C→B→F|
|22|无新的入度为0的顶点入栈，且栈为空，结束|D→E→A→C→B→F|

- 最短路程
 1. 单源最短路径
    G={V,E}，V<sub>0</sub>∈V，求V<sub>0</sub>到图中每个顶点路径
    - Dijkstra（迪杰斯特拉）算法思想：
    按照路径长度递增的顺序，依次产生最短路径
    例：![111](media/15041041474627/111.png)
    
    方法：使用如图所示的表
    ![112](media/15041041474627/112.png)

    A为起点，第一行：A与B、C、D的路径分别是10、3、20，没有与E的直接路径所以是∞，其中A到C路径最短，所以确定下来，这一列其他均为“-”；第二行：A通过C到B，路径为5，比A直接到B的路径10短，所以A到B的最短路径是5，A不能通过C到D，所以最短依然为20，A通过C到E的路径最短路径是18，取代∞，然后这一行5位最短，所以B列以后均为“-”；同理，一直到最后只剩一个不为“-”。所以可以根据表的得出A到每个点的最短路径

## 8. 查找和排序
 - 查找
    1. 线性表查找
        1. 顺序查找
        2. 折半查找（二分查找）
        3. 分块查找
    2. 树表查找（平衡的二叉排序树）
    3. 哈希查找（构造哈希函数）
    
### 8.1 线性表的查找
 - 顺序查找

``` cpp
seqSearch(int a[], int n, int x)
{
    int i = 0;
    while(x != a[i] && i < n)
        i++;
    if(x == a[i])
        printf("找到！\n");
    else 
        printf("不存在！\n");
}
```
 - 折半查找

``` cpp
halfSearch(int a[], int x, int n)
{
    int low, high, mid;
    low = 0;
    high = n - 1;
    mid = (low + high) / 2;
    while(x != a[mid] && low != high)
    {
        if(x > a[mid])
            low = mid + 1;
        else    
            high = mid - 1;
        mid = (low + high) / 2;
    }
    if(x == a[mid])
        printf("找到！");
    else
        printf("未找到！");
}
```
 - 分块查找

### 8.2 树表查找（平衡二叉树）
- 几个概念
    1. 平衡因子：树中任意结点的平衡因子等于左子树减去右子树的差
    2. 平衡二叉树：二叉树中每个结点的平衡因子的绝对值都不大于1
- 平衡化方法
找不满足平衡因子的结点，然后按照类型转换
    1. LL型
    ![L](media/15041041474627/LL.png)
    2. RR型
    ![R](media/15041041474627/RR.png)
    3. LR型
    ![L](media/15041041474627/LR.png)
    4. RL型
    ![R](media/15041041474627/RL.png)

例：{16,3,7,11,9,26,18,14,15}，建立平衡二叉树并计算ASL（平均查找长度）
ASL = 每个结点的路径长度之和÷结点数 = (1+2×2+4×3+2×4)÷9 = 2.78
        
### 8.3 哈希查找

- 哈希函数和哈希表

1. 哈希函数：
存储结点时以结点的关健值为自变量，按某种公式计算其存储地址，查找时再从以关键值为自变量，带入同一公式进行计算，从而实现对该结点的访问，通常计算结点存储地址的公式叫做哈希函数

2. 按照哈希函数构造的线性表

- 冲突
结点的关健值不同，但是它们的哈希函数值相同

- 解决冲突的常用方法

1. 开放地址法
    - 线性探测
    如果该结点地址已经有数据，那么依次探测该结点后方的`di`个结点，遇到空则放入(di=1,2,3...n)
    - 二次线性探测 
     如果该结点地址已经有数据，那么依次探测该结点后方的`±di²`个结点，遇到空则放入(di=1,2,3...n)

2. 拉链法（链地址法）
使用邻接表的方式表示，如下方例

3. 建立公共的溢出区

例：(47,7,29,11,16,92,22,8,3)，哈希表表长为11，H(key)=key mod 11.
(1)采用线性探测解决冲突，构造哈希表并计算ASL
(2)采用二次线性探测解决冲突，构造哈希表并计算ASL
(3)采用拉链法解决冲突，画出相应结构
解：
(1)ASL = (1+1+2+1+1+1+2+2+4)/9 ≈ 1.67
![1231231](media/15041041474627/1231231.png)
(2)ASL = (1+1+2+1+1+1+2+2+3)/9 ≈ 1.56
![阿斯顿23](media/15041041474627/%E9%98%BF%E6%96%AF%E9%A1%BF23.png)
(3)
![113123123123123123](media/15041041474627/113123123123123123.png)

## 9. 排序
 - 几个重要概念
 1. 排序：针对结点或记录的关键字，由小到大或者由大到小重组整个记录之间的次序
 2. 内部排序：待排关键字存储在内存中，并且排序所有过程也在内存中实现
 3. 外部排序：只要在排序过程中，有一次及以上的访问外存的过程都属于外部排序
 4. 稳定性：如果排序没有改变相同关键字之间的相对次序，那么这个排序就是稳定的，反之不稳定

### 9.1 排序的分类

- 插入排序

 1. 直接插入排序
时间复杂度：O(n<sup>2</sup>)
优点：简单，稳定
缺点：在关键字完全无序的情况下，效率最低

 2. 希尔排序
缺点：不稳定

- 交换排序

 1. 冒泡排序
时间复杂度：O(n<sup>2</sup>)
优点：简单，稳定，容易理解
缺点：处理海量数据效率低

 2. 快速交换排序
时间复杂度：O(nlgn)
缺点：不稳定

- 选择排序

 1. 简单选择排序：
时间复杂度：O(n<sup>2</sup>)
缺点：不稳定

 2. 堆排序：
时间复杂度：O(nlgn)
优点：适用于海量数据排序
缺点：不稳定，技巧最强，难度最大

- 归并排序

 1. 二路归并排序
时间复杂度：O(nlgn)
优点：稳定
缺点：内存需求较大
 
### 9.2 插入排序

- 直接插入排序
例：(91,67,35,62,29,72,46,57)
第1遍：`i=1`([**67 ~~91~~**(被覆盖，下同),91],35,62,29,72,46,57)
第2遍：`i=2`([**35 ~~67~~**,67,91],62,29,72,46,57)
第3遍：`i=3`([35,**61 ~~67~~**,67,91],29,72,46,57)
......
第7遍：`i=7`([29,35,46,**57 ~~62~~**,62,67,72,91])

- 希尔排序
按照序号分组，假如有n个数，第一次隔step=n/2个分组，把每个组内的数排序，然后再隔step=n/4个分组，再把每个组内的数排序......依次到最后，但是并不会直接有序，最后一次使用直接插入排序
例：(91,67,35,62,29,72,46,57)
(91<sup>1</sup>,67<sup>2</sup>,35<sup>3</sup>,62<sup>4</sup>,29<sup>1</sup>,72<sup>2</sup>,46<sup>3</sup>,57<sup>4</sup>)
第1遍：(29<sup>1</sup>,67<sup>2</sup>,35<sup>1</sup>,57<sup>2</sup>,91<sup>3</sup>,72<sup>4</sup>,46<sup>3</sup>,62<sup>4</sup>)
第2遍：(29<sup>1</sup>,57<sup>1</sup>,35<sup>2</sup>,67<sup>2</sup>,46<sup>3</sup>,62<sup>3</sup>,91<sup>4</sup>,72<sup>4</sup>)
第3遍：(29,57,35,67,46,62,72,91)

### 9.3 交换排序

- 冒泡排序

- 快速交换排序
设置两个变量i,j，分别赋值第一个值和最后一个值，以i为分界线，使左边都比i小，右边都比i大。
例：(49,38,65,97,76,30,45)
第1遍：([45,38,30],49,[76,97,65])
第2遍：([30,38],45,49,[65],76,[97])
第3遍：(30,38,45,49,65,76,97)

### 9.4 选择排序

- 简单选择排序
设置两个变量，i和j
例：(49,38,65,97,76,30)

- 堆排序
1. 堆：一组关键字序列{k<sub>1</sub>,k<sub>2</sub>...k<sub>n</sub>}，看做一棵完全二叉树，若该完全二叉树中所有非叶子结点的值均不大于（或均不小于）其左右孩子的值，则序列{k<sub>1</sub>,k<sub>2</sub>...k<sub>n</sub>}为一个堆

### 9.5 归并排序

- 二路归并排序

  
[^严格二叉树]: 一颗二叉树的每个非终端节点有且仅有两棵子树，则称这棵二叉树为严格二叉树。


