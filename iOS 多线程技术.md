# iOS 多线程技术

## 基本概念

### 进程（Process）

进程是指在系统中正在运行的一个应用程序，比如同时打开微信和 QQ，系统会分别至少启动 2 个进程。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。进程是系统进行资源分配和调度的一个独立单位。

> 注意
>
> 一个应用程序至少有一个进程，但不是说只有一个进程。

### 线程（Thread）

线程是某一个进程中一个单独运行的程序。线程是进程的一个实体。线程是 CPU 调度和分派的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它与同属一个进程的其他线程共享进程所拥有的全部资源。也就是线程存在于进程之中，一个进程由一个或多个线程构成，各线程之间共享相同的代码和全局数据，但各自有自己的堆栈。

一个程序有且只有一个主线程，与用户交互相关的中断性操作都会派发到主线程，程序启动时创建（调用main来启动），主线程的生命周期是和应用程序绑定，程序退出时，主线程也停止。

> 真正在应用程序中做任务的是线程。

### 任务（Task）

是指由应用程序完成的一个活动。一个任务既可以是一个进程，也可以是一个线程。任务是一系列为达到某一共同目的的操作集合。

### 进程和线程的区别和联系

- 线程是CPU和资源调度（执行任务）的基本单位，是程序执行的最小单元，进程是资源分配和调度的基本单位。

- 一个程序可以有多个进程，一个进程可以有多个线程，但至少要有一个线程，而一个线程只能属于一个进程。

- 同一个进程内的线程共享进程的所有资源。

### 并发

并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。一句话就是，表面上多个进程在被同时处理，而实际上每个时刻只有一个进程在被处理。

> 图1：并发

![并发](https://blog-image-1256099768.cos.ap-chengdu.myqcloud.com/blog-image/%E5%B9%B6%E5%8F%91.png)

### 并行

指在同一时刻，有多条指令在多个处理器上同时执行。即多个处理器或是多核的处理器同时处理多个不同的任务。

> 图2：并行

![并行](https://blog-image-1256099768.cos.ap-chengdu.myqcloud.com/blog-image/%E5%B9%B6%E8%A1%8C.png)

### 串行

各条机器指令按顺序串行执行，即执行完一条指命后，才取出下一条指令来执行。

### 多线程

多线程是指从硬件或软件上，实现多个线程并发执行的技术。

多线程能够同步完成多项任务，不是为了提高运行效率，而是为了提高资源利用率，从而提高应用程序的效率。如果线程很多，CPU 会在 N 多线程之间调度，会消耗大量 CPU 资源，每条线程被调度执行的频次会降低（线程的执行效率会降低)。

比如一个新闻类的应用程序，在新闻列表页需要加载新闻列表中的多个缩略图，如果缩略图和新闻标题的加载都在主线程完成的话，就会引起加载缓慢、反应迟钝的现象，从而影响应用程序的用户体验。这时可以将从服务器下载缩略图的任务，由一个单独的线程来完成，当该线程的下载任务完成后，再返回主线程显示下载的缩略图，从而尽可能减少对应用程序主线程的影响。

## 线程的相关概念

线程的执行顺序是串行执行。

### 线程的 Stack 空间

系统中的每一个进程都有自己独立的虚拟内存空间，而同一个进程中的多个线程则可共用进程的内存空间。每创建一个新的线程，都需要一些内存（如每个线程有自己的 Stack 空间）和消耗一定的 CPU 时间。另外当多个线程对同一个资源出现争夺的时候，需要注意线程的安全问题。

在 macOS 中，主线程的栈空间大小为 8MB，而在 iOS 中主线程的栈空间大小为 1MB，并且是不可修改的。应用程序子线程的默认栈空间大小为 512KB，栈空间不是立即被创建分配的，它会在线程的使用过程中逐渐增加。

子线程允许分配的最小栈空间是16KB，并且必须为4KB的整数倍。开发者可以通过 NSThread 线程对象的 stackSize 属性来修改一个子线程的栈空间。

### 线程的优先级

线程的优先级属性 threadPriority 是一个 0.0~1.0 之间的浮点数，1.0 表示最高的优先级，这和 iOS 操作系统的优先级是一致的，线程默认的优先级是 0.5。在执行顺序方面，优先级较高的线程先执行的可能性高于优先级较低的线程。

但是优先级较高的线程并不是 100% 的比优先级较低的线程先执行，只是优先级高的线程得到 CPU 调度的机率更高。

### 线程的生命周期

在线程自创建至消亡的整个生命周期中包含多个状态，各状态的具体说明如下：

- 新建状态：对线程对象进行初始化。

- 就绪状态：通过调用线程对象的 start 方法，将线程对象添加到可调试线程池，等待 CPU 的调度。

- 运行状态 ：通过 CPU 的调度使线程处于执行状态，在线程执行结束之前，线程的状态可能会在「就绪状态」和「运行状态」之间来回切换，并且两个状态之间的切换由 CPU 自行决定，而无法由开发者修改。

- 阻塞状态：通过调用 Thread 的类方法可以使线程休眠至指定的时间点，或在指定的时间范围内处于休眠的阻塞状态；或者通过 Lock 类和 Condition 类的实例对象的 lock 方法，以及 @synchronized 语句给线程加锁。

- 推出状态：当线程执行完毕后将自动处于正常消亡状态，调用 Thread 的类方法 exit 也可以终止线程的运行。

### 线程和 RunLoop

RunLoop 是线程中的一个对收到的事件进行处理的循环。每个线程都有都有唯一的 RunLoop 对象与之对应，主线程的 RunLoop 是自动创建并启动的。子线程的 RunLoop 需要手动创建，并且调用 run 方法启动，currentRunLoop 是延迟加载的，只创建一次。

### iOS 中的线程

#### 主线程

在 iOS 中，一个程序运行后会默认开启一条线程，称为「主线程」或「UI 线程」。

主线程的主要作用：

- 显示、刷新 UI 界面

- 处理 UI 事件（如拖拽、滚动、点击事件等）

主线程使用注意：

- 不要将耗时的操作放到主线程中（例如文件上传、下载等），耗时的操作会卡住主线程严重影响 UI 的流畅度，给用户一种「卡顿」的体验。

- 只要是 UI 有关的操作必须在主线程中处理。

- 无法通过代码开主线程，一个程序只有一个主线程，程序打开自动开主线程。

#### 非主线程

由代码开启的线程，一般用来处理耗时的操作，如网络请求等。

## iOS 的多线程技术

在 iOS 应用程序的开发技术体系中，共有四种主要的多线程技术，分别如下表： 、

> 表1：iOS 的多线程技术简介

| 技术方案 | <p style="text-align:center">简介</p>| 语言 | 线程生命周期 | 使用频率 |
| :--: | :-- | :--: | :--: | :--: |
| pthread | 1. 一套多线程API <br /> 2. 适用于 Unix\Linux\Windows 等系统 <br />3. 跨平台、可移植 <br /> 使用难度大 | C | 程序员管理 | 几乎不用 |
| NSThread | 1. 使用更加面向对象 <br /> 2. 简单易用,可直接操作线程对象 | Objective-C | 程序员管理 <br />（只管创建） | 偶尔不用 |
| ">**GCD** | 1. 旨在替代 NSThread 的多线程技术 <br /> 2. 充分利用设备的多核| C | 自动管理 | 经常使用 |
| **NSOpreation** | 1. 基于 GCD（底层是 GCD）<br /> 2. 比 GCD 多了些更简单实用的功能 <br /> 3. 使用更加面向对象 | Objective-C | 自动管理 | 经常使用 |

### NSThread

#### NSThread 的使用步骤

方法一：创建线程，手动启动线程。

1. 创建线程
    
    使用对象方法 `initWithTarget:selector:object:` 创建 NSThread 对象。
        
2. 启动线程

    使用对象方法 `strat` 启动线程对象。
    
方法二：分离出一条子线程，自动启动线程

直接使用类方法 `detachNewThreadSelector:toTarget:withObject:` 创建线程。

方法三：开启一条后台线程
    
直接对当前对象调用 `performSelectorInBackground:withObject:`方法创建后台线程。

> 注意
>
> 1. 上面三种方式中选择器参数传递的方法最多只能有一个参数，并且该方法不能有返回值。
> 2. 方法二和方法三虽然一条语句创建了线程，但是无法拿到线程对象，就无法设置线程的名称和优先级。
   
#### NSThread 的其他方法和属性
 
- `currentThread` 属性，获取当前线程。
- `threadPriority` 属性

    设置线程优先级，优先级类型为 double 类型，并且取值范围为 0.0~1.0，优先级最高 1.0，默认优先级 0.5。
    
    > 注意
    >
    > 优先级更高是指调用概率更高，而不是一定优先级低的线程就会在优先级高的线程后执行。

- `name` 属性，为线程设置名称。       
- `mainThread` 类方法，获取主线程。
- `isMainThread` 对象方法，判断是否为主线程。
- `sleepUntilDate` 类方法，阻塞（暂停）线程直到某时间，参数是 NSDate 类型。
- `sleepForTimeInterval` 类方法，阻塞线程，参数为阻塞线程的间隔时间，单位秒
- `exit` 类方法，强制退出当前线程。退出线程后会销毁线程对象，无法再次开启此线程。

#### NSThread 的生命周期和状态

NSThread 创建线程需要通过代码手动创建，但是 NSThread 的释放却是自动的，线程负责的任务全部执行完毕，程序会自动的释放 NSThread 线程。

> 图3：线程的状态

![线程的状态](https://blog-image-1256099768.cos.ap-chengdu.myqcloud.com/blog-image/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png)

> 注意
> 
> 线程对象一旦死亡（释放），就不能再次开启任务。

### GCD

GCD（Grand Central Dispatch，优秀的中枢调度器），纯 C 语言编写，提供了很多有用的函数。它是苹果公司为多核的并行运算提出的解决方案。GCD 会自动利用更多的 CPU 内核，并且会自动的管理线程的生命周期。

#### GCD 的任务和队列

GCD 中有两个核心的概念：

- 任务：执行什么操作。
- 队列：用来存放任务。

GCD 中的队列有主要有两种类型：

- **并发队列**：可以让多个任务并发（同时）执行，自动开启多个线程同时执行任务。
    
- **全局并发队列**：GCD 中本身存在的全局并发队列，它是供整个应用使用，无需手动创建。

- **串行队列**：让任务一个接一个的执行（一个任务执行完后开始执行下一个任务）。

- **主队列**：GCD 自带的一种特殊的串行队列，在主队列中的任务都会被放到主线程中执行。

#### GCD 的使用步骤

1. 创建队列

    创建队列的方式有 3 种。
    
   - 使用 `dispatch_queue_create()` 函数创建队列。
        
        返回值是 `dispatch_queue_t` 类型。
        第一个参数是 C 语言字符串，用来标识队列。
        第二个参数是队列的类型。队列的类型是用宏定义的。
         
        - `DISPATCH_QUEUE_CONCURRENT` 并发队列，
        - `DISPATCH_QUEUE_SERIAL` 串行队列。
    
    - 使用 `dispatch_get_global_queue()`函数创建全局并发队列。
        
        返回值也是 `dispatch_queue_t` 类型。
        第一个参数是队列优先级，也是宏。

        - `DISPATCH_QUEUE_PRIORITY_DEFAULT` 默认优先级
        - `DISPATCH_QUEUE_PRIORITY_HIGH` 最高优先级
        - `DISPATCH_QUEUE_PRIORITY_LOW` 低优先级
        - `DISPATCH_QUEUE_PRIORITY_BACKGROUND` 后台优先级，最低优先级
        
        第二个参数暂时无用，用 0 就可以了。
        
    - 使用 `dispatch_get_main_queue()` 获得主队列。没有参数。
    
    > 注意   
    >
    > 上诉三者的区别是，dispatch_queue_create() 函数用来创建队列；而 dispatch_get_global_queue() 和 dispatch_get_main_queue() 是获得 GCD 中本身存在的全局并发队列和主队列。
    
2. 封装任务

    使用同步或异步函数封装任务。并且将任务添加到队列中。封装任务这一步只需要使用同步或异步函数即可完成，函数会自动封装任务并将其添加到传入的队列参数中。
    GCD 会自动将队列中的任务取出放到对应的线程中执行。任务的取出遵循队列的 FIFO 原则（即**先进先出**原则）。

同步、异步方式配合并发、串行队列会有各种不同的效果。

同步和异步的区别：

- 同步：只能在当前线程中执行任务，不具备开启新线程的能力。
- 异步：可以在新的线程中执行任务，具备开启新线程的能力（只有是并发队列才会开线程）。

> 图4：GCD 不同的组合方式

![GCD 不同的组合方式](https://blog-image-1256099768.cos.ap-chengdu.myqcloud.com/blog-image/GCD%20%E4%BD%BF%E7%94%A8.png)

> 注意
> 
> 使用异步函数才会开启线程，并且开启线程的数量是不确定的。
> 如果是异步函数 + 串行队列的组合，则只会开启一条新线程。
> 如果是异步函数 + 并发队列的组合，则开启新线程的数量不确定，并不是有多少个任务就开多少个线程。具体是由系统决定的。
> 
     
#### GCD 常用函数

- 同步异步函数：    
    
    - `dispatch_sync()` 同步方式执行任务。立刻执行，如果当前任务没执行完毕，后面任务也不会执行。
    - `dispatch_async()` 异步方式执行任务。如果当当前任务没有执行完毕，后面的任务也可以执行。

    这两个函数的第一个参数是要添加的队列，第二个参数是封装任务的 Block 代码块。

- 延迟执行函数： 

    - `dispatch_after()` 延迟执行。

        第一个参数一般传递 `dispatch_time()` 函数，第二个参数传递延迟执行的队列，第三个参数是代码块回调，即执行的任务具体内容。
    
        `dispatch_time()` 函数有两个参数。
        第一个参数是时间，在延迟执行中默认使用 `DISPATCH_TIME_NOW` 宏表示当前时间。
        第二个参数是 int64_t 类型 (delayInSeconds * NSEC_PER_SEC) ，`NSEC_PER_SEC` 宏表示的是 GCD 的时间单位的九次方，GCD 的时间单位是纳秒，所以这个宏表示是秒，前面的 `delayInSeconds` 即表示多少秒。
    
        > 注意：
        >
        > 传入 dispatch_after() 中的队列如果是主队列，则在主线程中延迟执行，如果是全局并发队列，则在子线程中延迟执行。

- 一次性代码：即整个应用程序中只会执行一次

    - `dispatch_once()` 这个程序运行期间只会执行一次。
            
    第一个参数一般是传递一个名为 onceToken 的队列，在 Xcode 中创建这个函数的时候，使用快捷代码的方式会自动创建这个队列，这个队列是 static 修饰的，表示全局变量。第二个参数是代码块的回调。

- 栅栏函数：针对异步函数，在进程管理中起到一个栅栏的作用。它等待所有位于栅栏函数之前的操作执行完毕后执行，并且栅栏函数执行之后，栅栏函数之后的操作才会得到执行。

    - `dispatch_barrier_async()` 异步栅栏函数
        
        第一个参数是传入的队列，第二个参数是代码块。一般传入的队列是创建的并发队列。
        
        假如现在有 1、2、3、4 四个异步函数，在 2、3 异步函数之前插入栅栏函数。那么当程序运行时，1、2 异步函数会先并发执行，然后再执行栅栏函数，最后 3、4 异步函数再并发执行。即按照 1、2 --> 栅栏 -->3、4 这个顺序执行。且 1、2 之间，是并发执行的，两者之间顺序也不一定，同样 3、4 是并发执行的，两者之间顺序也不一定。
        
        > 注意：
        > 
        > 栅栏函数不能使用全局并发队列。
        
- 快速迭代[^迭代]：

- 队列组

[^迭代]: 对计算机特定程序中需要反复执行的子程序(一组指令)，进行一次重复，即重复执行程序中的循环，直到满足某条件为止，亦称为迭代。

### 多线程的安全

因为多线程是同时在处理任务，并且线程之间是共享资源的（这里的资源即变量、对象、文件等），所以很有可能会出现多个线程访问同一个资源。

当多个线程访问同一个资源的时候，就很容易出现数据错乱和数据安全的问题。如下图：

> 图5：多线程访问的数据安全问题

![线程出现安全问题](https://blog-image-1256099768.cos.ap-chengdu.myqcloud.com/blog-image/%E7%BA%BF%E7%A8%8B%E5%87%BA%E7%8E%B0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.png)

当然肯定会有解决方法，就是使用**互斥锁**的方式，当一个线程 A 在访问资源的时候，对资源「加锁」使其它线程无法访问这个资源，当线程 A 执行完任务，不需要再使用资源的时候，再将资源「解锁」，这时其他的线程才能够访问这个资源。如图：

> 图6：解决线程安全问题

![解决线程安全问题](https://blog-image-1256099768.cos.ap-chengdu.myqcloud.com/blog-image/%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.png)

#### 互斥锁的使用

在 iOS 中使用关键字 `@synchronized` 来使用互斥锁。使用格式：

> 代码1：互斥锁使用格式

```ObjectiveC
@synchronized(锁对象) {  // 实际开发中，锁对象一般就是 self
    // 需要锁定的代码 
    ...
}
```

> 注意：
> 
> 1. 锁定一份代码只用一把锁，用多把锁是无效的。
> 2. 注意加锁的位置。
> 3. 注意加锁的前提条件，多个线程共享同一数据资源，但不是多个线程共享同一资源就要加锁。
> 4. 加锁需要付出代价，需要消耗性能。
> 5. 加锁达到了线程同步[^线程同步]的目的。

[^线程同步]: 多条线程在一条线上按顺序执行任务。

### 线程间的通信

在一个进程中，线程都不是孤立存在的，多个线程之间需要经常通信。因为会有一个线程传递数据给另一个线程的情况，或者一个线程执行完指定任务后，交给另外的线程继续执行任务。所以出现这些情况的时候，就需要线程之间相互通信。

> 图6：线程间的通信示例

![线程间的通信示例](https://blog-image-1256099768.cos.ap-chengdu.myqcloud.com/blog-image/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B.png)

#### 线程间通信常用的方法

- `performSelectorOnMainThread:withObject:waitUntilDone:` 在主线程执行选择器方法。

- `performSelector:onThread:withObject:waitUntilDone:` 在指定的线程执行选择器方法。

- GCD 使用 `dispatch_get_main_queue()` 获得主队列来与主线程通信。

- `performSelector:withObject:afterDelay:` 延迟执行方法，在代码所在的线程执行选择器中的方法。




