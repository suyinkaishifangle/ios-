# UIView✅

> 📚 官方文档：**[View Programming Guide for iOS](https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503)**

UIView 是 UIKit 框架里面最基础的视图类，它是管理屏幕上矩形区域内容的对象。UIView 继承自 UIResponder。视图主要特性有以下三方面：

- **布局和管理子视图**

    视图可以包含零个或多个子视图，并且视图可以调整子视图的大小和位置。视图会按照层次结构排列，位于视图层次结构顶端的是应用的 UIWindow 对象（UIWindow 继承自 UIView）。

- **绘图和动画**

    视图使用 UIKit 或 Core Graphics 来绘制矩形区域的内容。

- **事件处理**

    视图对象在其边界（bounds）矩形内呈现内容，并响应触摸和其他类型的事件。

## 创建和配置视图对象

可以使用 xib 文件或 storyboard 文件或者以纯代码的方式来视图创建为对象，然后将它们组装到视图层次结构中以供使用。

- 纯代码创建视图对象

    视图的默认初始化方法是 `initWithFrame:` 方法，它设置视图相对于其父视图的初始大小和位置。例如，要创建一个新的 UIView 对象，可以使用类似于以下代码:

    ```Objective-C
    CGRect viewRect = CGRectMake(0, 0, 100, 100);
    UIView *myView = [[UIView alloc] initWithFrame:viewRect];
    ```

    > ⚠️ **注意**
    >
    > 尽管所有视图都支持 `initWithFrame:` 方法，但有些视图可能有首选的初始化方法（例如 UIButton 的 `buttonWithType:` 方法），此时应该选用首选初始化方法。

    创建视图后，可以为视图设置常用的属性，比如定义其外观、行为等。然后必须将视图添加到窗口（或窗口中的子视图），才能使其可见。

## 视图层次结构

视图除了提供自己的内容之外，还可以充当其他视图的容器：视图可以嵌套在其他视图中从而形成「视图层次结构」。当一个视图包含另一个视图时，将在两个视图之间创建父子关系，包含视图称为「父视图（superview）」（也叫「超视图」），被包含的视图称为「子视图（subview）」。父视图可以包含任意数量的子视图，但每个子视图只有一个父视图。

> **直接子视图**
> 
> 直接子视图是指视图最近关系的子视图，例如：视图 A 包含一个子视图 B，子视图 B 又包含一个子视图 C，从关系上来说 B 和 C 都是 A 的子视图，但是 B 是 A 的直接子视图，而 C 是 B 的直接子视图，C 不是 A 的直接子视图。

在视觉上，子视图的内容会覆盖其父视图的全部或部分内容。如果子视图完全不透明，那么子视图所占用区域会完全覆盖父视图的相应区域。如果子视图是部分透明的，则两个视图中的内容显示在屏幕上之前会被混合在一起。父视图会将其子视图存储在有序数组中，该数组中子视图的顺序也会影响各自的显示效果。例如两个兄弟子视图都添加到父视图上，那么后添加的子视图会出现在先添加的子视图之上。

在视图层次结构中，父视图负责定位和调整其子视图的大小，并且可以动态地改变。这种动态修改子视图的能力可以让视图根据不断变化的条件进行调整，比如界面旋转和动画。并且对父视图的一些更改也同样会影响到子视图，比如隐藏父视图、更改父视图的透明度等。

在视图层次结构中，窗口（UIWindow 对象）位于最底层，可以理解为「它是所有视图的父视图」。加入了窗口的视图会成为窗口的子视图，窗口的子视图还可以有自己的子视图，从而构成了一个以窗口为根视图的「视图层次结构」。下图是 Safari 浏览器的视图层次结构：

![Safari 浏览器视图层次结构](media/15530101886184/Safari%20%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%86%E5%9B%BE%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png)

视图层次结构形成后，系统会将其绘制到屏幕上，绘制过程可以分为两步：

1. 层次结构中的每个视图（包括窗口）分别绘制自己。视图会将自己绘制到图层（layer）上，每个 UIView 对象都有一个图层属性，指向一个 CALayer 类的对象。
2. 所有视图的图层组合成一个图像，绘制到屏幕上。

视图层次结构中的视图排列顺序也决定了应用程序如何响应事件。当在视图内发生触摸时，系统将触摸事件直接发送到该视图以进行处理。但是，如果视图不处理这个的触摸事件，它可以将触摸事件传递给其父视图。如果父视图也不处理触摸事件，它会将触摸事件传递给它的父视图，依此类推响应者链。视图还可以将触摸事件传递给介入的响应器对象，例如视图控制器。如果没有任何对象处理该触摸事件，这个触摸事件最终会传递给应用程序对象，应用程序对象通常会丢弃这个触摸事件。
  
## 视图绘制过程

视图使用按需绘制的模式来渲染内容（即视图可见时才绘制）。当视图首次显示时，系统会让视图绘制其内容，绘制内容后，系统捕获该内容的位图图像并缓存，并使用该位图作为视图的可视化表示。如果以后不会更改视图的内容，视图的绘图代码可能永远不会再被调用。如果视图内容发生改变（比如改变文字大小、背景颜色等），就需要重新绘制视图，再捕获视图新内容的位图图像，依此类推。

当绘制视图内容时，实际绘制过程会根据视图及其配置而有所不同。UIKit 提供的视图（比如：UIView、UIButton 等）的绘制方法都是私有的，不过这些 UIKit 视图通常会有配置视图实际外观的接口，开发者可以自己定制。对于自定义 UIView 子类，覆盖其 `drawRect:` 方法，使用该方法绘制视图的内容。当然还有其他方法可以提供视图的内容，例如直接设置底层的内容等，但是覆盖`drawRect:` 方法是最常用的技术。

当视图的实际内容发生更改时，需要通知系统重新绘制视图，通过调用视图的 `setNeedsDisplay` 或 `setNeedsDisplayInRect:` 方法来实现。这些方法让系统知道在下一次绘图周期中重新绘制视图。因为要等到下一个绘图周期更新视图，所以可以在多个视图上调用这些方法来同时更新它们。

> ⚠️ **注意**
>
> 更改视图的几何形状不会自动让系统重新绘制视图的内容。视图的 `contentMode` 属性（内容模式）决定如何显示视图几何形状的变化。大多数内容模式只是在视图边界内拉伸或重新定位已经缓存的位图图像，而不会重新绘制视图内容，具体参考视图内容模式。

## 视图内容模式

每个视图都有一个内容模式（`contentMode` 属性），内容模式指定视图的缓存位图图像在视图的几何形状改变时如何进行调整。`contentMode` 属性中的值决定了是否需要重新绘制视图内容。如果不需要重新绘制视图内容，则会缩放缓存位图图像以适应新的边界或者简单地将缓存位图固定到视图的一角或边缘（有可能导致内容失真、变形）。

只要执行以下操作，就会应用视图的内容模式：

- 更改视图框架矩形或边界矩形的宽度或高度。
- 将包含缩放系数的变换分配给视图的 `transform` 属性。

> ⚠️ **注意**
>
> 虽然内容模式可以决定是否需要重新绘制视图内容，但是可以通过直接调用 `setNeedsDisplay` 或`setNeedsDisplayInRect:` 方法来强制重绘视图的内容。

contentMode 属性是  UIViewContentMode 类型，该类型是一个枚举类型，默认值是 `UIViewContentModeScaleToFill`，具体枚举值如下：

| UIViewContentMode 枚举值 | 说明 | 效果 |
| :-: | :-: | :-: |
| UIViewContentModeScaleToFill | 更改图像的宽高比来缩放图像<br>以适应图像视图的大小。<br>（**图像会变形**） | ![UIViewContentModeScaleToFil](media/15508274740144/UIViewContentModeScaleToFill.png) |
| UIViewContentModeScaleAspectFit | 保持图像的宽高比来缩放图像<br>以适合图像视图的大小，<br>图像视图中没有被图像覆盖<br>到的区域是透明的。<br>（**图像不会变形**）| ![UIViewContentModeScaleAspectFit](media/15508274740144/UIViewContentModeScaleAspectFit.png) |
| UIViewContentModeScaleAspectFill | 保持图像的宽高比来缩放图像<br>以适合图像视图的大小。<br>会剪裁掉超出图像视图边界的部分。 | ![UIViewContentModeScaleAspectFil](media/15508274740144/UIViewContentModeScaleAspectFill.png) |
| UIViewContentModeCenter | 将图像放置于图像视图边界的中心<br>图像大小保持不变。 | ![UIViewContentModeCente](media/15508274740144/UIViewContentModeCenter.png) |
| UIViewContentModeTop | 将图像和图像视图边界的顶部中心对齐<br>保持大小保持不变。 | ![UIViewContentModeTop](media/15508274740144/UIViewContentModeTop.png) |
| UIViewContentModeBottom | 将图像和图像视图边界的底部中心对齐<br>保持大小保持不变。 | ![UIViewContentModeBotto](media/15508274740144/UIViewContentModeBottom.png) |
| UIViewContentModeLeft | 将图像和图像视图边界的左边中心对齐<br>保持大小保持不变。 | ![UIViewContentModeLeft](media/15508274740144/UIViewContentModeLeft.png) |
| UIViewContentModeRight | 将图像和图像视图边界的右边中心对齐<br>保持大小保持不变。 | ![UIViewContentModeRight](media/15508274740144/UIViewContentModeRight.png) |
| UIViewContentModeTopLeft | 将图像和图像视图边界的左上角对齐<br>保持大小保持不变。 | ![UIViewContentModeTopLeft](media/15508274740144/UIViewContentModeTopLeft.png) |
| UIViewContentModeTopRight | 将图像和图像视图边界的右上角对齐<br>保持大小保持不变。 | ![UIViewContentModeTopRight](media/15508274740144/UIViewContentModeTopRight.png) |
| UIViewContentModeBottomLeft | 将图像和图像视图边界的左下角对齐<br>保持大小保持不变。 | ![UIViewContentModeBottomLeft](media/15508274740144/UIViewContentModeBottomLeft.png) |
| UIViewContentModeBottomRight | 将图像和图像视图边界的右上角对齐<br>保持大小保持不变。 | ![UIViewContentModeBottomRight](media/15508274740144/UIViewContentModeBottomRight.png) |
| UIViewContentModeRedraw | 调用 setNeedsDisplay 方法在<br>更改边界时重新显示视图。<br>尽可能避免使用这个值。 | ![UIViewContentModeRedra](media/15508274740144/UIViewContentModeRedraw.png) |

内容模式有利于减少视图重复绘制。但也可以将内容模式设置为 `UIViewContentModeRedraw` 值，当特别需要自定义视图在缩放和调整操作期间重绘自身时，将视图的内容模式设置为该值将强制调用视图的 `setNeedsDisplay` 方法重新绘制视图。通常，应该尽可能地避免使用这个值。

## 视图几何形状和坐标系统

UIKit 中的默认的屏幕坐标系的原点在左上角，X 轴从原点向右延伸为正方向，Y 轴从原点向下延伸为正方向。坐标值使用浮点数表示，这种方式不需要考虑底层屏幕分辨率而能精确的布局和定位。除了屏幕坐标系之外，窗口和视图还定义了自己的坐标系，允许指定相对于视图或窗口原点的坐标，而不是相对于屏幕的坐标。不过在 iOS 中，窗口都会占满整个屏幕，所以窗口的坐标系和屏幕的坐标系相同。

每次绘制视图或更改其几何图形时，都会相对于某个坐标系进行绘制。在绘图的情况下，可以指定相对于视图自身坐标系的坐标。在几何形状更改的情况下，可以指定相对于父视图坐标系的坐标。UIWindow 和 UIView 类都包含从一个坐标系转换到另一个坐标系的方法。因为每个视图和窗口都定义了自己的局部坐标系，所以需要明确在具体情况下使用哪个坐标系。

> ⚠️ **注意**
>
> 一些 iOS 技术定义的默认坐标系统原点和方向与 UIKit 使用的坐标系统不同。例如，Core Graphics 和 OpenGL ES 使用的坐标系统原点位于视图或窗口的左下角，Y 轴相对于屏幕向上指向。在绘制或创建内容时，必须考虑到这些差异，并根据需要调整坐标值。

### frame、bounds 和 center 属性

- frame 属性

    CGRect 类型，视图的「框架矩形」，用于描述视图在父视图坐标系中的大小和位置。

    这个矩形定义了视图在其父视图坐标系中的大小和位置。在布局操作期间使用这个矩形来设置视图的大小和位置。设置此属性将更改 `center` 属性的值，并相应地更改边界矩形中的大小。

    使用构造方法 `initWithFrame:` 可以通过代码在初始化视图时给视图的 `frame` 属性赋值，或者在初始化完成后再给视图的 `frame` 属性赋值。此属性的值是一个 CGRect 结构体类型，包含另外两个结构体：`origin` 和 `size`。

    - origin 的类型是 CGPoint 结构体，它包含两个 CGFloat 类型的成员：x 和 y。表示以**当前视图的父视图的框架矩形的左上角为坐标原点**时，当前视图矩形的左上角所在位置的坐标。
    - size 的类型是 CGSize 结构体，size 也包含两个 CGFloat 类型的成员：width 和 height。表示该视图的大小。

    下图是一个子视图 blueView 相对于父视图 greenView 的坐标，其中子视图 blueView 的 `frame = (50,50,175,80)`。从图中可以看出子视图 frame 属性的 origin 值以其父视图矩形的左上角为坐标原点。

    ![子视图在父视图坐标系中的定位](media/15530101886184/%E5%AD%90%E8%A7%86%E5%9B%BE%E5%9C%A8%E7%88%B6%E8%A7%86%E5%9B%BE%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%BD%8D.png)

    > ⚠️ **注意**
    >
    > 更改此属性的值不会重新绘制视图内容，不调用其 `drawRect:` 方法。如果想让 UIKit 在框架矩形改变时调用 `drawRect:` 方法，则将 `contentMode` 属性设置为 `UIViewContentModeRedraw`。

- bounds 属性

    CGRect 类型，视图的「边界矩形」，它描述视图在其自身坐标系中的大小和位置（及其内容原点）。

    默认边界矩形的原点为 (0,0)，其大小与框架矩形大小相同。改变矩形的大小部分，可以使视图相对于其中心点增大或缩小。改变大小也会改变框架矩形的大小以匹配。边界矩形的坐标总是用点表示。bounds 属性是一个 CGRect 结构体类型，包含另外两个结构体：`origin` 和 `size`

    - origin 的类型是 CGPoint 结构体，它包含两个 CGFloat 类型的成员：x 和 y。表示以**当前视图的左上角为坐标原点**时，当前视图矩形的左上角所在位置的坐标（也就是 bounds 属性的 origin 的 x 和 y 永远是 0 ）。
    - size 的类型是 CGSize 结构体，size 也包含两个 CGFloat 类型的成员：width 和 height。表示该视图的大小。

    下图是一个视图 blueView 相对于自身的坐标，其中视图 blueView 的 `bounds = (0,0,175,80)`。从图中可以看出视图 blueView 的 bounds 属性的 origin 值以其自身矩形的左上角为坐标原点。

    ![视图在自身坐标系中的定位](media/15530101886184/%E8%A7%86%E5%9B%BE%E5%9C%A8%E8%87%AA%E8%BA%AB%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%BD%8D.png)

    > ⚠️ **注意**
    >
    > 同样更改边界矩形不会重新绘制视图内容，不调用其 `drawRect:` 方法。如果想让 UIKit 在框架矩形改变时调用 `drawRect:` 方法，则将 `contentMode` 属性设置为 `UIViewContentModeRedraw`。

- center 属性

    CGPoint 类型，视图的**框架矩形**的中心点。

    center 属性值的是 CGPoint 结构体，包含两个 CGFloat 类型的值：x 和 y，分别表示的是**视图中心点相对于父视图坐标系的横坐标和纵坐标**。

    > ⚠️**注意**
    >
    > center 属性的中心点是相对于父视图坐标系的，而不是相对于自身的坐标系。父视图的 center 属性和子视图的 center 属性不一定相等。

**总结**

以上三个属性中，当更改其中一个属性的值时，另外两个属性的值也会发生相应的变化。如下：

- 设置 frame 属性时，bounds 属性中的大小值会改变为框架矩形的新大小，center 属性中的值也会相应改变为框架矩形的新中心点。

- 设置 center 属性时，frame 属性中的 origin 值会相应改变。

- 设置 bounds 属性的大小时，frame 属性中的大小值将改变为边界矩形的新大小。

在构建视图层次结构或在运行时更改视图的位置或大小时使用这些属性。主要使用 frame 属性来控制当前视图的大小和位置，使用 center 属性控制当前视图的位置，使用 bounds 属性控制当前视图的大小。例如，如果只更改视图的位置（而不更改其大小），使用 center 属性是首选的方法。

## 视图交互过程

下面的步骤解释了在程序运行时视图与用户交互的过程：

1. 用户触摸屏幕。

2. 硬件将触摸事件报告给 UIKit 框架。

3. UIKit 框架将触摸发送给到 UIEvent 对象，并将其分派到适当的视图中。

4. 视图处理响应事件执行代码。例如，代码可能：
  
    - 更改视图或其子视图的属性（frame、bounds、alpha 等）。
    - 调用 `setNeedsLayout` 方法将视图（或其子视图）标记为需要更新布局。
    - 调用 `setNeedsDisplay` 或 `setNeedsDisplayInRect:` 方法将视图（或其子视图）标记为需要重新绘制。
    - 通知控制器更改某些数据。

5. 如果视图的几何形状改变，UIKit 会根据以下规则更新它的子视图：

    - 如果视图配置了自动布局规则，UIKit 会根据这些规则调整每个视图。
    - 如果视图实现了 `layoutSubviews` 方法，UIKit 会调用它。
  
6. 如果视图被标记为需要重新绘制，UIKit 会要求视图重新绘制自身。
    
    UIKit 调用 `drawRect:` 方法。此时不要进行额外的布局更改，也不要对应用程序的数据模型进行其他更改。此方法的目的是更新视图的可视内容。

7. 任何更新的视图都与应用程序的其他可见内容组合在一起，并发送到图形硬件以供显示。

8. 图形硬件将渲染的内容传输到屏幕。

## 自定义视图

如果标准系统视图不能完全满足开发需要，开发者可以自定义一个视图。自定义视图完全控制视图内容的外观以及如何处理与该内容的交互。下面是自定义视图的步骤：

1.  初始化自定义视图

    - 对于以要从 xib 或 storyboard 文件中加载的视图，重写 initWithCoder: 方法。
    - 对于以纯代码编程方式创建的视图，重写 initWithFrame: 方法或定义自定义初始化方法。
  
    自定义的每个新视图对象都应该包含一个自定义的 initWithFrame: 初始化方法。此方法负责在创建时初始化类并将视图对象放入已知状态。下面代码显示了标准 initWithFrame: 方法的基本实现。这个方法首先调用方法的继承实现，然后初始化类的实例变量和状态信息，最后返回初始化的视图对象。

    ```Objective-C
    - (instancetype)initWithFrame:(CGRect)frame {
      if (self = [super initWithFrame:frame]) {
        // 设置视图的初始属性
        ...
      }
      return  self;
    }
    ```

2. 如果自定义视图类中管理一个或多个子视图，执行以下操作：

    - 在第 1 步的初始化方法中创建这些子视图对象，并设置每个子视图的 autoresizingMask 属性。
    - 如果子视图使用手动布局的方式（frame 属性），重写 layoutSubviews 方法并在其中实现布局代码。

> ⚠️ **注意**
>
> 使用手动布局的方式只能在 layoutSubviews 方法中对子视图进行布局。因为需要使用 frame 属性，而初始化方法中父视图对象还没有完成初始化，所以在其中使用 frame 属性布局无效。

3. 绘制自定义视图 

    对于需要进行自定义绘图的视图，需要重写 drawRect: 方法并在其中进行绘图。一般来说，如果可以使用其他子视图来呈现内容，则尽量不采用这种方式。

4. 响应事件

    视图对象是响应者对象——UIResponder 类的实例，因此能够接收触摸事件。当发生触摸事件时，窗口将相应的事件对象分派给发生触摸的视图。可以使用下面两种方式来响应事件：

    - 添加手势识别器：可以使用 addGestureRecognizer: 方法将手势识别器附加到视图上。
    - 直接处理触摸事件：重写 touchesBegan:withEvent:、 touchesMoved:withEvent:、 touchesEnded:withEvent:、touchesCancelled:withEvent: 方法。（应该总是重写 touchesCancelled:withEvent: 方法，而不管重写了哪些其他与触摸相关的方法）

    视图的默认行为是每次只响应一次触摸。如果用户放下第二根手指，系统就会忽略触摸事件，不会向视图报告它。如果想要从视图的事件处理程序方法跟踪多指手势，则需要通过将视图的 multipleTouchEnabled 属性设置为 YES 来启用多点触摸事件。

    有些视图，如 UILable 和 UIImageView 对象，默认完全禁用事件处理。可以通过更改视图的 userInteractionEnabled 属性的值来控制视图是否能够接收触摸事件。为了防止事件到达您的任何视图，还可以使用 UIApplication 对象的beginIgnoringInteractionEvents 和 endIgnoringInteractionEvents 方法。这些方法影响整个应用程序的事件处理，而不仅仅是单个视图。

    > ⚠️ **注意**
    >
    > UIView 的动画方法通常在动画进行时禁用触摸事件。

## 线程问题

对应用程序用户界面的操作必须在主线程上进行。因此，应该**总是从应用程序主线程中调用 UIView 类的方法**。不过在创建视图对象本身时，可以不在主线程中执行，但是对视图的所有其他操作都应该在主线程上执行。

## 核心动画层

[About Core Animation](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514)

每个视图对象都有一个专用的核心动画层，用于管理屏幕上视图内容的显示和动画。可以根据需要直接使用相应的图层对象。视图的图层对象存储在视图的 `layer` 属性中。

创建视图后，无法更改与视图关联的图层类型。因此，每个视图都使用 `layerClass` 类方法来指定其图层对象的类。此方法的默认实现返回 CALayer 类。可以重写 `layerClass` 类方法来使用其他类型的图层。例如，如果视图使用平铺显示大型可滚动区域，则可能需要使用 CATiledLayer 类图层来支持视图。

每个视图在其初始化过程的早期调用 `layerClass` 方法，并使用返回的类来创建其图层对象。视图始终将自己指定为其图层对象的代理。此时，视图拥有其图层，视图和图层之间的关系不能更改。并且一个图层对象只能被一个视图对象代理，更改视图的所有权或代理关系将导致绘图问题和应用程序中的潜在崩溃。

## 视图的属性和方法

### 配置视图的外观

- **backgroundColor** 属性

    UIColor 类型，视图的背景颜色，默认值为 `nil`。此属性的更改可以动画化，此时背景颜色透明。

- **hidden** 属性

    BOOL 类型，是否隐藏视图，默认值是 `NO`。

    将此属性的值设置为 `YES` 将隐藏视图，将其设置为 `NO` 将显示视图。
  
    被隐藏的视图会从窗口中消失，并且不接收输入事件。但是它仍然在父视图的子视图数组中，也就存在于视图层级结构中，并不会被释放。如果父视图被隐藏，那么它的子视图都将被隐藏，无论子视图的 `hidden` 属性为何值。如果视图被隐藏前是第一响应者，那么视图被隐藏后将由层级结构中下方的视图充当第一响应者。

    > ⚠️ **注意**
    >
    > 使用 `hidden` 属性和使用 `removeFromSuperview` 方法的本质区别：
    >
    > 1. `hidden` 属性不会销毁视图，不会修改视图的引用，也不会删除视图的约束，仅仅是将视图隐藏起来使其无法与用户交互。
    > 2. `removeFromSuperview` 方法是直接将视图从层级结构中删除，同时删除视图的约束，并且会修改视图的引用，所以有可能会使视图对象被销毁（当视图引用计数器为 0 时销毁）。但是要注意，并不是引用计数器为 0 时马上就销毁视图。

- **alpha** 属性

    CGFloat 类型，视图的透明度。默认值为 `1.0`。
  
    该属性的值是范围为 `0.0` 到 `1.0` 的浮点数，其中 `0.0` 表示完全透明，`1.0` 表示完全不透明。更改此属性的值只更新当前视图的 alpha 值。但是，alpha 值所赋予的透明度会影响视图的所有内容，包括它的子视图。例如，一个 alpha 值为 1.0 的子视图嵌入到一个 alpha 值为 0.5 的父视图中，在屏幕上显示时就好像子视图的 alpha 值也是 0.5 一样。

- **opaque** 属性

    BOOL 类型，确定视图是否不透明，默认值为 `YES`。

    这个属性为绘图系统提供了一个提示，说明它应该如何处理视图。如果设置为 `YES`，绘图系统将视图视为完全不透明的，这样绘图时能优化一些绘图操作并提高性能。如果设置为 `NO`，绘图系统通常会将视图与其他内容组合在一起。
    
    一个不透明的视图应该用完全不透明的内容来填充，也就是说，内容的 `alpha` 值应该为 `1.0`。如果视图是不透明的，或者没有完全填充，或者包含全部或部分透明的内容，那么结果不可预测。如果视图是完全透明或部分透明的，则应该始终将此属性的值设置为 `NO`。
    
    不透明属性对系统提供的类没有影响，比如 UIButton、UILabel、UITableViewCell 等等。

- **tintColor** 属性

    UIColor 类型，色调值。默认值为 `nil`，表示使用父视图此属性的值。
    
    此属性定义了一个可以传递的颜色值，默认情况下（此属性为 `nil`），子视图继承父视图的颜色——也就是子视图此属性为 `nil` 时，子视图的 `tintColor` 值等于父视图的 `tintColor`值。因此，这个值总是会返回一个颜色值，即没有指定它（最终返回的是窗口对象的 `tintColor` 值，因为窗口是所有视图的父视图。）
    
    窗口（UIWindow）默认的此属性值并不为 `nil`，当窗口的子视图没有自定义 `tintColor` 属性时，那么都会使用窗口的`tintColor` 值。所以默认情况下，整个应用程序的视图的 `tintColor` 最终表现出来的颜色是窗口 `tintColor` 属性的值：RGB 为 `(0,122,1)`。
    
    此属性表示视图的色调，在不同类型的视图中，这个属性的作用也不同。例如在 UITextField 对象中，此属性表示输入框的光标颜色。
    
    > ⚠️ **注意**
    >
    > 不能够将图案颜色用作色调，否则系统会引发异常。

- **tintAdjustmentMode** 属性

    UIViewTintAdjustmentMode 类型，色调调整模式，默认值为 `UIViewTintAdjustmentModeAutomatic`。
    
    此属性的值用于调整 `tintColor` 属性的值定义的颜色。UIViewTintAdjustmentMode 是枚举类型，如下：
    
    | UIViewTintAdjustmentMode | 说明 |
    | :-: | :-: |
    | UIViewTintAdjustmentModeAutomatic | 与父视图的色调调整模式相同，如果没有父视图，<br>则为 UIViewTintAdjustmentModeNormal。 |
    | UIViewTintAdjustmentModeNormal | 不修改 tintColor 属性的颜色值。 |
    | UIViewTintAdjustmentModeDimmed | tintColor 属性的颜色值去饱和，变暗淡。 |

- **clipsToBounds** 属性

    BOOL 类型，确定子视图是否局限于父视图的范围内，默认值 `NO`。

    将此值设置为 `YES` 会使子视图中超出父视图边界的部分被剪切。如果设置为 `NO`，则超出父视图边界的子视图部分不会被剪切。

    > ⚠️ **注意**
    >
    > 在父视图边界矩形之外的子视图部分发生的触摸事件不会传递到该子视图。无论此属性的值为 `YES` 还是 `NO`。

- **clearsContextBeforeDrawing** 属性

    BOOL 类型，用于确定在绘制之前是否应自动清除视图的边界，此属性的默认值为 `YES`。
    
    设置为 `YES` 时，在调用 `drawRect:` 方法之前，绘图缓冲区将自动清除为透明黑色。此行为可确保在重绘视图的内容时不会留下任何可视构件。如果视图的 `opaque` 属性也设置为 `YES`，则视图的 `backgroundColor` 属性不能为 `nil`，否则可能会出现绘图错误。

    如果将此属性的值设置为 `NO`，则必须确保在 `drawRect:` 方法中正确绘制视图的内容。如果绘图代码已经经过了大幅优化，那么将此属性设置为 `NO` 可以提高性能，尤其是在滚动时，可能只需要重绘部分视图。

- **maskView** 属性

    UIView 类型，一个可选视图，其 alpha 通道用于屏蔽视图的内容（即视图的遮罩）。
    
    视图的 alpha 通道决定了视图的内容和背景显示了多少。完全或部分不透明像素允许底层内容通过但完全透明的像素块显示该内容。

- **layerClass** 类属性

    Class 类型，只读。返回用于为此类的实例创建图层的类。
    
    默认情况下，此方法返回 CALayer 类对象。子类可以覆盖此方法，并根据需要返回不同的层类。例如，如果视图使用平铺显示大型可滚动区域，则可能需要覆盖此属性并返回 CATiledLayer 类。在创建视图的早期只调用此方法一次，以便创建相应的图层对象。

- **layer** 属性

    CALayer 类型，只读。用于渲染视图的核心动画层。

    这个属性永远不为 `nil`。对象的实际类由 `layerClass` 属性返回的值决定。视图是图层的代理。
    
    > ⚠️ **注意**
    >
    > 因为视图是图层的代理，所以永远不要让视图成为另一个 CALayer 对象的代理。此外，永远不要更改这个图层对象的代理。
    
### 管理视图层次结构

- **superview** 属性

    UIView 类型，只读。表示父视图，如果没有，则为 `nil`。视图只能有一个父视图。

- **subviews** 属性

    NSArray 类型，只读。此属性包含所有直接子视图。
  
    子视图在数组中的排列顺序反映了它们在屏幕上的可见顺序和添加到父视图上的顺序，数组索引 0 处的视图是最先添加的子视图，数组最后一个索引处的视图显示在所有兄弟视图的最上方。

- **window** 属性

    UIWindow 类型，只读。表示视图所属的窗口。如果视图尚未添加到窗口，则此属性为 `nil`。

- **addSubview:** 方法

    将指定的视图添加到接收者的子视图数组的末尾。

    - 参数一：UIView 类型，要添加的视图。添加后，此视图将显示在任何其他兄弟视图的上方。

    该方法会建立一个视图的强引用，并将其下一个响应者设置为该方法的接收者，这是它的新父视图。如果被添加的视图已经有一个父视图，而这个父视图不是方法的接收者，则会在使接收者成为新的父视图之前删除被添加视图先前的父视图。

- **bringSubviewToFront:** 方法

    移动指定的子视图，使其显示在所有兄弟视图之上。

    - 参数一：UIView 类型，要移动的视图。

    此方法将指定视图移动到子视图数组的末尾。

- **sendSubviewToBack:** 方法

    移动指定的子视图，使其显示在所有兄弟视图之下。
    
    - 第一个参数：UIView 类型，要移动的视图。
  
    此方法将指定视图移动到子视图数组的开头。

- **removeFromSuperview** 方法

    将视图从其父视图中移除。调用此方法将删除父视图对视图的引用，并且也会删除视图添加的所有约束，还会删除此视图对子视图的引用。

    > ⚠️ **注意**
    > 
    > 切勿在视图的 `drawRect:` 方法中调用此方法。

- **insertSubview:atIndex:** 方法

    在子视图数组中指定的索引处插入子视图。

    - 参数一：UIView 类型，要插入的视图。
    - 参数二：NSInteger 类型，子视图数组中的索引位置。子视图索引从 0 开始，不能大于子视图的数量。

    该方法会建立一个对插入视图的强引用。如果插入的视图已经有一个父视图，而那个父视图不是次方法的接收者，那么该方法在使接收方成为新的父视图之前删除该视图先前的父视图。

- **insertSubview:aboveSubview:** 方法

    在视图层次结构中的另一个视图上方插入视图。

    - 参数一：UIView 类型，要插入的视图。
    - 参数二：UIView 类型，视图插入后其下方的兄弟视图。

    该方法建立一个对插入视图的强引用。如果插入的视图已经有一个父视图，而那个父视图不是次方法的接收者，那么该方法在使接收方成为新的父视图之前删除该视图先前的父视图。

- **insertSubview:belowSubview:** 方法

    在视图层次结构中的另一个视图下方插入一个视图。

    - 参数一：UIView 类型，要插入的视图。
    - 参数二：UIView 类型，视图插入后其上方的兄弟视图。

    该方法建立一个对插入视图的强引用。如果插入的视图已经有一个父视图，而那个父视图不是次方法的接收者，那么该方法在使接收方成为新的父视图之前删除该视图先前的父视图。

- **exchangeSubviewAtIndex:withSubviewAtIndex:** 方法

    交换两个子视图的索引。

    - 参数一：NSInteger 类型，第一个子视图的索引。
    - 参数二：NSInteger 类型，第二个子视图的索引。

    每个索引表示子视图在父视图数组中的位置。子视图索引从 0 开始，不能大于子视图的数量。这个方法不改变任何一个视图的父视图，而是简单地交换它们在子视图数组中的位置。

> 🔥 **提示**
>
> 使用上面的几个方法来插入子视图或者交换子视图的顺序的方式，比删除子视图并重新插入它们要快。

- **isDescendantOfView:** 方法

    返回一个布尔值，指示该方法的接收者是给定视图的子视图还是与该视图相同。

    - 参数一：UIView 类型，接收方中第一个子视图的索引。

    如果该方法的接收者是参数一的直接子视图或远子视图，或者是接收者自身，返回 `YES`，否则返回 `NO`。
      
### ⌛️绘制和更新视图

- **drawRect** 方法

  在传入的矩形内绘制接收方的图像。

  - 第一个参数：CGRect 类型，视图边界需要更新的部分。第一次绘制视图时，此矩形通常是视图的整个可见边界。在后续绘制操作期间，矩形可能只是指定视图的一部分。

  此方法的默认实现不执行任何操作。 使用 Core Graphics 和 UIKit 等技术绘制视图内容的子类应重写此方法并在其中实现其绘图代码。 如果视图以其他方式设置其内容，则无需覆盖此方法。 例如，如果视图仅显示背景颜色，或者视图使用其他类型的子视图作为其内容，则无需覆盖此方法。

  首次显示视图或发生使视图的可见部分无效的事件时，将调用此方法。 永远不应该直接调用这个方法。 若要使视图的一部分无效，从而导致重绘该部分，则调用 setNeedsDisplay 或 setNeedsDisplayInRect: 方法。

- **setNeedsDisplay** 方法

  将接收方的整个边界矩形标记为需要重新绘制。

  可以使用此方法或 setNeedsDisplayInRect: 方法来通知系统视图内容需要重绘。 此方法记录请求并立即返回。 在下一个绘制周期时，视图会重新绘制。

  只有在视图的内容或外观发生更改时，才应使用此方法请求重绘视图。 如果只是更改视图的几何图形，则通常不会重绘视图。 而是根据视图的 contentMode 属性中的值调整其现有内容。 重新显示现有内容可以避免无用的重新绘制操作，从而提高性能。

- **setNeedsDisplayInRect:** 方法

  将接收方指定的矩形区域标记为需要重新绘制。

  - 第一个参数：CGRect 类型，指定需要重绘的矩形，这个矩形在接收方自身坐标系中指定。

  可以使用此方法或 setNeedsDisplayInRect: 方法来通知系统视图内容需要重绘。 此方法记录请求并立即返回。 在下一个绘制周期时，视图会重新绘制。

  只有在视图的内容或外观发生更改时，才应使用此方法请求重绘视图。 如果只是更改视图的几何图形，则通常不会重绘视图。 而是根据视图的 contentMode 属性中的值调整其现有内容。 重新显示现有内容可以避免无用的重新绘制操作，从而提高性能。

- ⌛️**contentScaleFactor** 属性
- ⌛️**tintColorDidChange** 方法
  
### 管理手势识别器

- **addGestureRecognizer:** 方法

    为视图添加手势识别器。

    - 参数一：UIGestureRecognizer 类型，要添加手势识别器，不能为 `nil`。

    将手势识别器添加到视图，使其接收对该视图及其所有子视图的手势事件。该视图建立了对手势识别器的强引用。

- **removeGestureRecognizer:** 方法

    从视图中移除手势识别器。

    - 参数一：UIGestureRecognizer 类型，要移除的手势识别器。

    除了从视图中移除手势识别器之外，此方法还会释放手势识别器对象。

- **gestureRecognizers** 属性

    NSArray 类型。包含当前已经添加到视图的手势识别器对象。默认值为 `nil`。

- **gestureRecognizerShouldBegin:** 方法

    询问是否应允许手势识别器继续跟踪触摸事件。

    - 参数一：UIGestureRecognizer 类型，正在尝试从 `Possible` 状态转换到其他状态的手势识别器。
    - 返回值：BOOL 类型，如果手势识别器继续跟踪触摸事件并触发手势，则为 `YES`；如果手势识别器应转换为 `Failed` 状态，则为 `NO`。

    此方法的默认实现返回 `YES`，子类可以覆盖此方法来阻止识别特定手势。例如：UISlider 类使用此方法来防止与滑块的移动方向平行且从大拇指开始的滑动。
    
    在调用此方法时，手势识别器处于 `Possible` 状态，并已经接收能转换到 `Began` 状态所需的事件。 
    
### 布局子视图

- **layoutSubviews** 方法

    布局子视图。如果要实现此方法，**必须继承父类的 layoutSubviews 方法**。

    要在自定义视图的实现中布局子视图，才应覆盖此方法。实现此方法可以其中手动布局子视图。

    不应该直接调用此方法。如果要强制进行布局更新，在下次绘图更新之前调用 `setNeedsLayout` 方法。如果要立即更新视图的布局，调用 `layoutIfNeeded` 方法。
    
    > ⚠️ **注意**
    >
    > 一定不能够将约束添加到此方法中。

- **setNeedsLayout** 方法

    使视图的当前布局无效并在下一个更新周期中触发布局更新。

    如果要调整视图的子视图布局，在主线程上调用此方法。此方法记录请求并立即返回。由于此方法不强制立即更新，而是等待下一个更新周期，因此可以在更新任何视图之前使用它来使多个视图的布局无效。此行为允许将所有布局的更新合并到一个更新周期，这通常会提高性能。

- **layoutIfNeeded** 方法

    如果布局更新处于待处理状态，则立即布置子视图。

    使用此方法强制视图立即更新其布局。使用“自动布局”时，布局引擎会根据需要更新视图的位置，以满足约束的更改。使用以根视图接收消息的视图，此方法从根开始布局视图子树。如果没有待处理的布局更新，则此方法退出而不修改布局或调用任何与布局相关的回调。

- **translatesAutoresizingMaskIntoConstraints** 属性

    BOOL 类型，用于确定视图的 `autoresizingMask` 属性是否已转换为自动布局的约束。

    默认情况下，以纯代码方式创建的任何视图，该属性都默认为 `YES`。 如果使用 xib 文件或 storyboard 文件添加的视图，系统会自动将此属性设置为 `NO`。

    如果此属性的值为 `YES`，系统将创建一组约束，这些约束将复制视图的 `autoresizingMask` 属性指定的行为。如果要使用约束布局，则必须将此属性设置为 `NO`，然后为视图不冲突的约束集。
     
### 配置调整大小行为

- **autoresizesSubviews** 属性

    BOOL 类型，确定子视图在父视图的边界更改时是否自动调整其子视图的大小。默认值为 `YES`。

    设置 `YES` 为时，子视图在父视图边界更改时调整其子视图的大小。

- **autoresizingMask** 属性

    [UIViewAutoresizing](https://developer.apple.com/documentation/uikit/uiviewautoresizing?language=objc) 类型，用于确定视图在父视图的边界发生变化时如何调整自身大小。默认值为 `UIViewAutoresizingNone`，表示不自动调整视图的大小。

    当父视图的边界发生变化时，父视图会根据每个子视图的 `autoresizingMask` 属性的值自动调整其子视图的大小。通过组合 `UIViewAutoresizing` 类型的常量，可以指定视图的哪些维度相对于父视图应该增大或缩小。 
  
- **sizeThatFits:** 方法

    要求视图计算并返回最适合指定大小的大小。
    
    - 参数一：CGSize 类型，最佳的大小。
    - 返回值：CGSize 类型，适合子视图的新大小。
    
    此方法的默认实现返回视图的现有大小。子类可以重写此方法，根据所需子视图的所需布局返回自定义值。例如，UISwitch 对象返回一个固定大小的值，表示切换视图的标准大小，UIImageView 对象返回当前显示的图像的大小。此方法不会调整接收器的大小。
    
    如果使用了约束布局视图，那么此方法失效。
    
- **sizeToFit** 方法

    调整接收者视图的大小并移动它，使其只包含子视图。
    
    如果要调整当前视图的大小以便使用最合适的空间量，则调用此方法。具体的 UIKit 视图根据自己的内部需求调整自己的大小。在某些情况下，如果视图没有父视图，则可能会将其自身调整为屏幕边界。因此，如果希望给定视图将其自身调整为其父视图，则应在调用此方法之前将其添加到父视图。

    不应该重写此方法。如果要更改视图的默认大小调整信息，则重写 `sizeThatFits:`。该方法执行任何所需的计算并将它们返回到此方法，然后进行更改。
    
### 配置与事件相关的行为

- **userInteractionEnabled** 属性

    BOOL 类型，确定是否忽略用户事件并从事件队列中删除该事件，默认值为 `YES`。
    
    此属性设置为 `NO` 时，将忽略 touch、press、keyboard 和 focus 事件，并将其从事件队列中删除该事件。设置为 `YES` 时，事件将正常传递到视图。
    
    在视图进行动画期间，无论此属性中的值如何，都会暂时禁用动画中涉及的所有视图的用户交互。不过可以通过在配置动画时指定 `UIViewAnimationOptionAllowUserInteraction` 选项来启用与视图的交互。

- **multipleTouchEnabled** 属性

    BOOL 类型，指示视图是否一次接收多个触摸，默认值为 `NO`。
    
    设置为 `YES` 时，视图将接收与多点触控序列关联的所有触摸。设置为 `NO` 时，视图仅接收在视图边界内开始的多点触摸序列中的第一个触摸事件。
    
- **exclusiveTouch** 属性

    BOOL 类型，指示视图是否只由自己处理触摸事件。默认值为 `NO`。
    
    将此属性设置为 `YES` 会使视图阻止将触摸事件传递到同一窗口中的其他视图。
  
### 观察与视图相关的更改

当把子视图添加到另一个视图时，UIKit 通知父视图和子视图相关更改。可以通过重写下面这些方法来更新与视图层次结构相关的任何状态信息或执行其他任务。

- **didAddSubview:** 方法

    告诉视图添加了一个子视图。

    - 参数一：UIView 类型，被添加的子视图。
  
    此方法的默认实现不执行任何操作。子类可以重写它，在添加子视图时执行其他操作。在使用任何与添加子视图有关的方法时会自动调用此方法。

- **willRemoveSubview:** 方法

    告诉视图将要删除子视图。

    - 第一个参数：UIView 类型，将要被移除的子视图。

    此方法的默认实现不执行任何操作。子类可以重写它，在子视图将要被删除时执行其他操作。当子视图的父视图发生变化或子视图完全从视图层次结构中删除时，将自动调用此方法。

- **willMoveToSuperview:** 方法

    告诉视图它的父视图将更改为指定的父视图。

    - 参数一：UIView 类型，将要成为接收者新父视图的视图，可以为 `nil`。

    此方法的默认实现不执行任何操作。子类可以重写它，在父视图改变时执行其他操作。

- **willMoveToWindow:**

    告诉视图它的窗口即将改变。

    - 参数一：UIWindow 类型，将要成为接收者新视图层次结构的根目录下的窗口对象。可以为 `nil`。

    此方法的默认实现不执行任何操作。子类可以重写它，在窗口改变时执行其他操作。

- **didMoveToSuperview** 方法

    告诉视图它的父视图已经改变。

    此方法的默认实现不执行任何操作。子类可以重写它，在父视图改变时执行其他操作。

- **didMoveToWindow**

    告诉视图它的窗口对象已经改变。

    此方法的默认实现不执行任何操作。子类可以重写它，在窗口改变时执行其他操作。当调用此方法时，窗口属性可能为 `nil`，这表示接收方当前不在任何窗口中。当接收方刚刚从其父视图中删除，或者接收方刚刚被添加到不附加到窗口的父视图中时，就会发生这种情况。
    
### 在视图坐标系之间转换

- **convertPoint:toView:** 方法

    将指定点从接收者的坐标系转换为指定视图的坐标系。
    
    - 参数一：CGPoint 类型，在接收者的坐标系中指定的点。
    - 参数二：UIView 类型，新坐标系的视图。如果为 `nil`，则此方法将坐标转换为窗口坐标。
    - 返回值：CGPoint 类型，该点在新视图坐标系中的坐标。

- **convertPoint:fromView:** 方法

    将点从另一个视图的坐标系转换为接收者的坐标系。
    
    - 参数一：CGPoint 类型，在参数二视图坐标系中指定的点。
    - 参数二：UIView 类型，指定点原来坐标系的视图。如果为 `nil`，则此方法将从窗口坐标转换。
    - 返回值：CGPoint 类型，该点在接收者坐标系中的坐标。
    
- **convertRect:toView:** 方法

    将矩形从接收者的坐标系转换为另一个视图的的坐标系。
    
    - 参数一：CGRect 类型，在接收者坐标系中指定的矩形。
    - 参数二：UIView 类型，新坐标系的视图。如果为 `nil`，则此方法将坐标转换为窗口坐标。
    - 返回值：CGRect 类型，转换后的矩形。

- **convertRect:fromView:**

    将矩形从另一个视图的坐标系转换为接收者的坐标系。
    
    - 参数一：CGRect 类型，在参数二视图的坐标系中指定的矩形。
    - 参数二：UIView 类型，指定矩形原来坐标系的视图。如果为 `nil`，则此方法将从窗口坐标转换。
    - 返回值：CGRect 类型，转换后的矩形。

### 使用动画效果

http://liuyanwei.jumppo.com/2015/11/01/iOS-MotionEffects.html

### 结束视图编辑会话

- **endEditing:** 方法

    指定视图（或其包含的文本框）是否结束输入状。
    
    - 参数一：BOOL 类型，是否结束输入状态。
    
    此方法查找当前第一响应者的文本框的视图及其子视图层次结构。如果找到一个，则使用参数一确定其是否结束输入状态（即是否取消第一响应者）。
     
    
    

